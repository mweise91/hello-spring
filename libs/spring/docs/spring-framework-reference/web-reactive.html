<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Web on Reactive Stack</title>
<style>
/* https://github.com/bclozel/asciidoctor-stylesheet-factory/tree/spring */
/* ===================================================================== */

@import url('stylesheets/asciidoctor-spring.css');

/* https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
/* ============================================================================ */

@import url('tocbot-3.0.2/tocbot.css');

#tocbot a.toc-link.node-name--H1{ font-style: italic }
@media screen{
#tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
#tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
  padding-left: 0 }
#tocbot a.toc-link{ height:100% }
.is-collapsible{ max-height:3000px; overflow:hidden; }
.is-collapsed{ max-height:0 }
.is-active-link{ font-weight:700 }
}
@media print{
#tocbot a.toc-link.node-name--H4{ display:none }
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body id="spring-web-reactive" class="book toc2 toc-left">
<div id="header">
<h1>Web on Reactive Stack</h1>
<div class="details">
<span id="revnumber">version 5.1.4.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#webflux">1. Spring WebFlux</a>
<ul class="sectlevel2">
<li><a href="#webflux-new-framework">1.1. Overview</a>
<ul class="sectlevel3">
<li><a href="#webflux-why-reactive">1.1.1. Define &#8220;Reactive&#8221;</a></li>
<li><a href="#webflux-reactive-api">1.1.2. Reactive API</a></li>
<li><a href="#webflux-programming-models">1.1.3. Programming Models</a></li>
<li><a href="#webflux-framework-choice">1.1.4. Applicability</a></li>
<li><a href="#webflux-server-choice">1.1.5. Servers</a></li>
<li><a href="#webflux-performance">1.1.6. Performance</a></li>
<li><a href="#webflux-concurrency-model">1.1.7. Concurrency Model</a></li>
</ul>
</li>
<li><a href="#webflux-reactive-spring-web">1.2. Reactive Core</a>
<ul class="sectlevel3">
<li><a href="#webflux-httphandler">1.2.1. <code>HttpHandler</code></a></li>
<li><a href="#webflux-web-handler-api">1.2.2. <code>WebHandler</code> API</a>
<ul class="sectlevel4">
<li><a href="#webflux-web-handler-api-special-beans">Special bean types</a></li>
<li><a href="#webflux-form-data">Form Data</a></li>
<li><a href="#webflux-multipart">Multipart Data</a></li>
<li><a href="#webflux-forwarded-headers">Forwarded Headers</a></li>
</ul>
</li>
<li><a href="#webflux-filters">1.2.3. Filters</a>
<ul class="sectlevel4">
<li><a href="#webflux-filters-cors">CORS</a></li>
</ul>
</li>
<li><a href="#webflux-exception-handler">1.2.4. Exceptions</a></li>
<li><a href="#webflux-codecs">1.2.5. Codecs</a>
<ul class="sectlevel4">
<li><a href="#webflux-codecs-jackson">Jackson JSON</a></li>
<li><a href="#webflux-codecs-forms">Form Data</a></li>
<li><a href="#webflux-codecs-multipart">Multipart</a></li>
<li><a href="#webflux-codecs-streaming">Streaming</a></li>
<li><a href="#webflux-codecs-buffers"><code>DataBuffer</code></a></li>
</ul>
</li>
<li><a href="#webflux-logging">1.2.6. Logging</a>
<ul class="sectlevel4">
<li><a href="#webflux-logging-id">Log Id</a></li>
<li><a href="#webflux-logging-sensitive-data">Sensitive Data</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-dispatcher-handler">1.3. <code>DispatcherHandler</code></a>
<ul class="sectlevel3">
<li><a href="#webflux-special-bean-types">1.3.1. Special Bean Types</a></li>
<li><a href="#webflux-framework-config">1.3.2. WebFlux Config</a></li>
<li><a href="#webflux-dispatcher-handler-sequence">1.3.3. Processing</a></li>
<li><a href="#webflux-resulthandling">1.3.4. Result Handling</a></li>
<li><a href="#webflux-dispatcher-exceptions">1.3.5. Exceptions</a></li>
<li><a href="#webflux-viewresolution">1.3.6. View Resolution</a>
<ul class="sectlevel4">
<li><a href="#webflux-viewresolution-handling">Handling</a></li>
<li><a href="#webflux-redirecting-redirect-prefix">Redirecting</a></li>
<li><a href="#webflux-multiple-representations">Content Negotiation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-controller">1.4. Annotated Controllers</a>
<ul class="sectlevel3">
<li><a href="#webflux-ann-controller">1.4.1. <code>@Controller</code></a></li>
<li><a href="#webflux-ann-requestmapping">1.4.2. Request Mapping</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-requestmapping-uri-templates">URI Patterns</a></li>
<li><a href="#webflux-ann-requestmapping-pattern-comparison">Pattern Comparison</a></li>
<li><a href="#webflux-ann-requestmapping-consumes">Consumable Media Types</a></li>
<li><a href="#webflux-ann-requestmapping-produces">Producible Media Types</a></li>
<li><a href="#webflux-ann-requestmapping-params-and-headers">Parameters and Headers</a></li>
<li><a href="#webflux-ann-requestmapping-head-options">HTTP HEAD, OPTIONS</a></li>
<li><a href="#webflux-ann-requestmapping-composed">Custom Annotations</a></li>
<li><a href="#webflux-ann-requestmapping-registration">Explicit Registrations</a></li>
</ul>
</li>
<li><a href="#webflux-ann-methods">1.4.3. Handler Methods</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-arguments">Method Arguments</a></li>
<li><a href="#webflux-ann-return-types">Return Values</a></li>
<li><a href="#webflux-ann-typeconversion">Type Conversion</a></li>
<li><a href="#webflux-ann-matrix-variables">Matrix Variables</a></li>
<li><a href="#webflux-ann-requestparam"><code>@RequestParam</code></a></li>
<li><a href="#webflux-ann-requestheader"><code>@RequestHeader</code></a></li>
<li><a href="#webflux-ann-cookievalue"><code>@CookieValue</code></a></li>
<li><a href="#webflux-ann-modelattrib-method-args"><code>@ModelAttribute</code></a></li>
<li><a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a></li>
<li><a href="#webflux-ann-sessionattribute"><code>@SessionAttribute</code></a></li>
<li><a href="#webflux-ann-requestattrib"><code>@RequestAttribute</code></a></li>
<li><a href="#webflux-multipart-forms">Multipart Content</a></li>
<li><a href="#webflux-ann-requestbody"><code>@RequestBody</code></a></li>
<li><a href="#webflux-ann-httpentity"><code>HttpEntity</code></a></li>
<li><a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a></li>
<li><a href="#webflux-ann-responseentity"><code>ResponseEntity</code></a></li>
<li><a href="#webflux-ann-jackson">Jackson JSON</a></li>
</ul>
</li>
<li><a href="#webflux-ann-modelattrib-methods">1.4.4. <code>Model</code></a></li>
<li><a href="#webflux-ann-initbinder">1.4.5. <code>DataBinder</code></a></li>
<li><a href="#webflux-ann-controller-exceptions">1.4.6. Managing Exceptions</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-rest-exceptions">REST API exceptions</a></li>
</ul>
</li>
<li><a href="#webflux-ann-controller-advice">1.4.7. Controller Advice</a></li>
</ul>
</li>
<li><a href="#webflux-fn">1.5. Functional Endpoints</a>
<ul class="sectlevel3">
<li><a href="#webflux-fn-overview">1.5.1. Overview</a></li>
<li><a href="#webflux-fn-handler-functions">1.5.2. HandlerFunction</a>
<ul class="sectlevel4">
<li><a href="#webflux-fn-request"><code>ServerRequest</code></a></li>
<li><a href="#webflux-fn-response"><code>ServerResponse</code></a></li>
<li><a href="#webflux-fn-handler-classes">Handler Classes</a></li>
<li><a href="#webflux-fn-handler-validation">Validation</a></li>
</ul>
</li>
<li><a href="#webflux-fn-router-functions">1.5.3. <code>RouterFunction</code></a>
<ul class="sectlevel4">
<li><a href="#webflux-fn-predicates">Predicates</a></li>
<li><a href="#webflux-fn-routes">Routes</a></li>
<li><a href="#nested-routes">Nested Routes</a></li>
</ul>
</li>
<li><a href="#webflux-fn-running">1.5.4. Running a Server</a></li>
<li><a href="#webflux-fn-handler-filter-function">1.5.5. Filtering Handler Functions</a></li>
</ul>
</li>
<li><a href="#webflux-uri-building">1.6. URI Links</a>
<ul class="sectlevel3">
<li><a href="#web-uricomponents">1.6.1. UriComponents</a></li>
<li><a href="#web-uribuilder">1.6.2. UriBuilder</a></li>
<li><a href="#web-uri-encoding">1.6.3. URI Encoding</a></li>
</ul>
</li>
<li><a href="#webflux-cors">1.7. CORS</a>
<ul class="sectlevel3">
<li><a href="#webflux-cors-intro">1.7.1. Introduction</a></li>
<li><a href="#webflux-cors-processing">1.7.2. Processing</a></li>
<li><a href="#webflux-cors-controller">1.7.3. <code>@CrossOrigin</code></a></li>
<li><a href="#webflux-cors-global">1.7.4. Global Configuration</a></li>
<li><a href="#webflux-cors-webfilter">1.7.5. CORS <code>WebFilter</code></a></li>
</ul>
</li>
<li><a href="#webflux-web-security">1.8. Web Security</a></li>
<li><a href="#webflux-view">1.9. View Technologies</a>
<ul class="sectlevel3">
<li><a href="#webflux-view-thymeleaf">1.9.1. Thymeleaf</a></li>
<li><a href="#webflux-view-freemarker">1.9.2. FreeMarker</a>
<ul class="sectlevel4">
<li><a href="#webflux-view-freemarker-contextconfig">View Configuration</a></li>
<li><a href="#webflux-views-freemarker">FreeMarker Configuration</a></li>
</ul>
</li>
<li><a href="#webflux-view-script">1.9.3. Script Views</a>
<ul class="sectlevel4">
<li><a href="#webflux-view-script-dependencies">Requirements</a></li>
<li><a href="#webflux-view-script-integrate">Script Templates</a></li>
</ul>
</li>
<li><a href="#webflux-view-httpmessagewriter">1.9.4. JSON and XML</a></li>
</ul>
</li>
<li><a href="#webflux-caching">1.10. HTTP Caching</a>
<ul class="sectlevel3">
<li><a href="#webflux-caching-cachecontrol">1.10.1. <code>CacheControl</code></a></li>
<li><a href="#webflux-caching-etag-lastmodified">1.10.2. Controllers</a></li>
<li><a href="#webflux-caching-static-resources">1.10.3. Static Resources</a></li>
</ul>
</li>
<li><a href="#webflux-config">1.11. WebFlux Config</a>
<ul class="sectlevel3">
<li><a href="#webflux-config-enable">1.11.1. Enabling WebFlux Config</a></li>
<li><a href="#webflux-config-customize">1.11.2. WebFlux config API</a></li>
<li><a href="#webflux-config-conversion">1.11.3. Conversion, formatting</a></li>
<li><a href="#webflux-config-validation">1.11.4. Validation</a></li>
<li><a href="#webflux-config-content-negotiation">1.11.5. Content Type Resolvers</a></li>
<li><a href="#webflux-config-message-codecs">1.11.6. HTTP message codecs</a></li>
<li><a href="#webflux-config-view-resolvers">1.11.7. View Resolvers</a></li>
<li><a href="#webflux-config-static-resources">1.11.8. Static Resources</a></li>
<li><a href="#webflux-config-path-matching">1.11.9. Path Matching</a></li>
<li><a href="#webflux-config-advanced-java">1.11.10. Advanced Configuration Mode</a></li>
</ul>
</li>
<li><a href="#webflux-http2">1.12. HTTP/2</a></li>
</ul>
</li>
<li><a href="#webflux-client">2. WebClient</a>
<ul class="sectlevel2">
<li><a href="#webflux-client-builder">2.1. Configuration</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-builder-reactor">2.1.1. Reactor Netty</a>
<ul class="sectlevel4">
<li><a href="#webflux-client-builder-reactor-resources">Resources</a></li>
<li><a href="#webflux-client-builder-reactor-timeout">Timeouts</a></li>
</ul>
</li>
<li><a href="#webflux-client-builder-jetty">2.1.2. Jetty</a></li>
</ul>
</li>
<li><a href="#webflux-client-retrieve">2.2. <code>retrieve()</code></a></li>
<li><a href="#webflux-client-exchange">2.3. <code>exchange()</code></a></li>
<li><a href="#webflux-client-body">2.4. Request Body</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-body-form">2.4.1. Form Data</a></li>
<li><a href="#webflux-client-body-multipart">2.4.2. Multipart Data</a></li>
</ul>
</li>
<li><a href="#webflux-client-filter">2.5. Client Filters</a></li>
<li><a href="#webflux-client-testing">2.6. Testing</a></li>
</ul>
</li>
<li><a href="#webflux-websocket">3. WebSockets</a>
<ul class="sectlevel2">
<li><a href="#websocket-intro">3.1. Introduction to WebSocket</a>
<ul class="sectlevel3">
<li><a href="#websocket-intro-architecture">3.1.1. HTTP Versus WebSocket</a></li>
<li><a href="#websocket-intro-when-to-use">3.1.2. When to Use WebSockets</a></li>
</ul>
</li>
<li><a href="#webflux-websocket-server">3.2. WebSocket API</a>
<ul class="sectlevel3">
<li><a href="#webflux-websocket-server-handler">3.2.1. Server</a></li>
<li><a href="#webflux-websockethandler">3.2.2. <code>WebSocketHandler</code></a></li>
<li><a href="#webflux-websocket-databuffer">3.2.3. <code>DataBuffer</code></a></li>
<li><a href="#webflux-websocket-server-handshake">3.2.4. Handshake</a></li>
<li><a href="#webflux-websocket-server-config">3.2.5. Server Configation</a></li>
<li><a href="#webflux-websocket-server-cors">3.2.6. CORS</a></li>
<li><a href="#webflux-websocket-client">3.2.7. Client</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-test">4. Testing</a></li>
<li><a href="#webflux-reactive-libraries">5. Reactive Libraries</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This part of the documentation covers support for reactive-stack web applications built on a
<a href="http://www.reactive-streams.org/">Reactive Streams</a> API to run on non-blocking
servers, such as Netty, Undertow, and Servlet 3.1+ containers. Individual chapters cover
the <a href="#webflux">Spring WebFlux</a> framework,
the reactive <a href="#webflux-client"><code>WebClient</code></a>, support for <a href="#webflux-test">testing</a>,
and <a href="#webflux-reactive-libraries">reactive libraries</a>. For Servlet-stack web applications, see
<a href="web.html#spring-web">Web on Servlet Stack</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux"><a class="anchor" href="#webflux"></a>1. Spring WebFlux</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The original web framework included in the Spring Framework, Spring Web MVC, was
purpose-built for the Servlet API and Servlet containers. The reactive-stack web framework,
Spring WebFlux, was added later in version 5.0. It is fully non-blocking, supports
<a href="http://www.reactive-streams.org/">Reactive Streams</a> back pressure, and runs on such servers as
Netty, Undertow, and Servlet 3.1+ containers.</p>
</div>
<div class="paragraph">
<p>Both web frameworks mirror the names of their source modules
(<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a> and
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a>)
and co-exist side by side in the Spring Framework. Each module is optional.
Applications can use one or the other module or, in some cases, both&#8201;&#8212;&#8201;for example, Spring MVC controllers with the reactive <code>WebClient</code>.</p>
</div>
<div class="sect2">
<h3 id="webflux-new-framework"><a class="anchor" href="#webflux-new-framework"></a>1.1. Overview</h3>
<div class="paragraph">
<p>Why was Spring WebFlux created?</p>
</div>
<div class="paragraph">
<p>Part of the answer is the need for a non-blocking web stack to handle concurrency with a
small number of threads and scale with fewer hardware resources. Servlet 3.1 did provide
an API for non-blocking I/O. However, using it leads away from the rest of the Servlet API,
where contracts are synchronous (<code>Filter</code>, <code>Servlet</code>) or blocking (<code>getParameter</code>,
<code>getPart</code>). This was the motivation for a new common API to serve as a foundation across
any non-blocking runtime. That is important because of servers (such as Netty) that are
well-established in the async, non-blocking space.</p>
</div>
<div class="paragraph">
<p>The other part of the answer is functional programming. Much as the addition of annotations
in Java 5 created opportunities (such as annotated REST controllers or unit tests), the addition
of lambda expressions in Java 8 created opportunities for functional APIs in Java.
This is a boon for non-blocking applications and continuation-style APIs (as popularized
by <code>CompletableFuture</code> and <a href="http://reactivex.io/">ReactiveX</a>) that allow declarative
composition of asynchronous logic. At the programming-model level, Java 8 enabled Spring
WebFlux to offer functional web endpoints alongside annotated controllers.</p>
</div>
<div class="sect3">
<h4 id="webflux-why-reactive"><a class="anchor" href="#webflux-why-reactive"></a>1.1.1. Define &#8220;Reactive&#8221;</h4>
<div class="paragraph">
<p>We touched on &#8220;non-blocking&#8221; and &#8220;functional&#8221; but what does reactive mean?</p>
</div>
<div class="paragraph">
<p>The term, &#8220;reactive,&#8221; refers to programming models that are built around reacting to change&#8201;&#8212;&#8201;network components reacting to I/O events, UI controllers reacting to mouse events, and others.
In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode
of reacting to notifications as operations complete or data becomes available.</p>
</div>
<div class="paragraph">
<p>There is also another important mechanism that we on the Spring team associate with &#8220;reactive&#8221;
and that is non-blocking back pressure. In synchronous, imperative code, blocking calls
serve as a natural form of back pressure that forces the caller to wait. In non-blocking
code, it becomes important to control the rate of events so that a fast producer does not
overwhelm its destination.</p>
</div>
<div class="paragraph">
<p>Reactive Streams is a
<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#specification">small spec</a>
(also <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html">adopted</a> in Java 9)
that defines the interaction between asynchronous components with back pressure.
For example a data repository (acting as
<a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html">Publisher</a>)
can produce data that an HTTP server (acting as
<a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html">Subscriber</a>)
can then write to the response. The main purpose of Reactive Streams is to let the
  subscriber to control how quickly or how slowly the publisher produces data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Common question: what if a publisher cannot slow down?</strong><br>
The purpose of Reactive Streams is only to establish the mechanism and a boundary.
If a publisher cannot slow down, it has to decide whether to buffer, drop, or fail.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-reactive-api"><a class="anchor" href="#webflux-reactive-api"></a>1.1.2. Reactive API</h4>
<div class="paragraph">
<p>Reactive Streams plays an important role for interoperability. It is of interest to libraries
and infrastructure components but less useful as an application API, because it is too
low-level. Applications need a higher-level and richer, functional API to
compose async logic&#8201;&#8212;&#8201;similar to the Java 8 <code>Stream</code> API but not only for collections.
This is the role that reactive libraries play.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor">Reactor</a> is the reactive library of choice for
Spring WebFlux. It provides the
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html"><code>Mono</code></a> and
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html"><code>Flux</code></a> API types
to work on data sequences of 0..1 (<code>Mono</code>) and 0..N (<code>Flux</code>) through a rich set of operators aligned with the
ReactiveX <a href="http://reactivex.io/documentation/operators.html">vocabulary of operators</a>.
Reactor is a Reactive Streams library and, therefore, all of its operators support non-blocking back pressure.
Reactor has a strong focus on server-side Java. It is developed in close collaboration
with Spring.</p>
</div>
<div class="paragraph">
<p>WebFlux requires Reactor as a core dependency but it is interoperable with other reactive
libraries via Reactive Streams. As a general rule, a WebFlux API accepts a plain <code>Publisher</code>
as input, adapts it to a Reactor type internally, uses that, and returns either a
<code>Flux</code> or a <code>Mono</code> as output. So, you can pass any <code>Publisher</code> as input and you can apply
operations on the output, but you need to adapt the output for use with another reactive library.
Whenever feasible (for example, annotated controllers), WebFlux adapts transparently to the use
of RxJava or another reactive library. See <a href="#webflux-reactive-libraries">Reactive Libraries</a> for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-programming-models"><a class="anchor" href="#webflux-programming-models"></a>1.1.3. Programming Models</h4>
<div class="paragraph">
<p>The <code>spring-web</code> module contains the reactive foundation that underlies Spring WebFlux,
including HTTP abstractions, Reactive Streams <a href="#webflux-httphandler">adapters</a> for supported
servers, <a href="#webflux-codecs">codecs</a>, and a core <a href="#webflux-web-handler-api"><code>WebHandler</code> API</a> comparable to
the Servlet API but with non-blocking contracts.</p>
</div>
<div class="paragraph">
<p>On that foundation, Spring WebFlux provides a choice of two programming models:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-controller">Annotated Controllers</a>: Consistent with Spring MVC and based on the same annotations
from the <code>spring-web</code> module. Both Spring MVC and WebFlux controllers support reactive
(Reactor and RxJava) return types, and, as a result, it is not easy to tell them apart. One notable
difference is that WebFlux also supports reactive <code>@RequestBody</code> arguments.</p>
</li>
<li>
<p><a href="#webflux-fn">Functional Endpoints</a>: Lambda-based, lightweight, and functional programming model. You can think of
this as a small library or a set of utilities that an application can use to route and
handle requests. The big difference with annotated controllers is that the application
is in charge of request handling from start to finish versus declaring intent through
annotations and being called back.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-framework-choice"><a class="anchor" href="#webflux-framework-choice"></a>1.1.4. Applicability</h4>
<div class="paragraph">
<p>Spring MVC or WebFlux?</p>
</div>
<div class="paragraph">
<p>A natural question to ask but one that sets up an unsound dichotomy. Actually, both
work together to expand the range of available options. The two are designed for
continuity and consistency with each other, they are available side by side, and feedback
from each side benefits both sides. The following diagram shows how the two relate, what they
have in common, and what each supports uniquely:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-mvc-and-webflux-venn.png" alt="spring mvc and webflux venn">
</div>
</div>
<div class="paragraph">
<p>We suggest that you consider the following specific points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you have a Spring MVC application that works fine, there is no need to change.
Imperative programming is the easiest way to write, understand, and debug code.
You have maximum choice of libraries, since, historically, most are blocking.</p>
</li>
<li>
<p>If you are already shopping for a non-blocking web stack, Spring WebFlux offers the same
execution model benefits as others in this space and also provides a choice of servers
(Netty, Tomcat, Jetty, Undertow, and Servlet 3.1+ containers), a choice of programming models
(annotated controllers and functional web endpoints), and a choice of reactive libraries
(Reactor, RxJava, or other).</p>
</li>
<li>
<p>If you are interested in a lightweight, functional web framework for use with Java 8 lambdas
or Kotlin, you can use the Spring WebFlux functional web endpoints. That can also be a good choice
for smaller applications or microservices with less complex requirements that can benefit
from greater transparency and control.</p>
</li>
<li>
<p>In a microservice architecture, you can have a mix of applications with either Spring MVC
or Spring WebFlux controllers or with Spring WebFlux functional endpoints. Having support
for the same annotation-based programming model in both frameworks makes it easier to
re-use knowledge while also selecting the right tool for the right job.</p>
</li>
<li>
<p>A simple way to evaluate an application is to check its dependencies. If you have blocking
persistence APIs (JPA, JDBC) or networking APIs to use, Spring MVC is the best choice
for common architectures at least. It is technically feasible with both Reactor and
RxJava to perform blocking calls on a separate thread but you would not be making the
most of a non-blocking web stack.</p>
</li>
<li>
<p>If you have a Spring MVC application with calls to remote services, try the reactive <code>WebClient</code>.
You can return reactive types (Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a>)
directly from Spring MVC controller methods. The greater the latency per call or the
interdependency among calls, the more dramatic the benefits. Spring MVC controllers
can call other reactive components too.</p>
</li>
<li>
<p>If you have a large team, keep in mind the steep learning curve in the shift to non-blocking,
functional, and declarative programming. A practical way to start without a full switch
is to use the reactive <code>WebClient</code>. Beyond that, start small and measure the benefits.
We expect that, for a wide range of applications, the shift is unnecessary. If you are
unsure what benefits to look for, start by learning about how non-blocking I/O works
(for example, concurrency on single-threaded Node.js) and its effects.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-server-choice"><a class="anchor" href="#webflux-server-choice"></a>1.1.5. Servers</h4>
<div class="paragraph">
<p>Spring WebFlux is supported on Tomcat, Jetty, Servlet 3.1+ containers, as well as on
non-Servlet runtimes such as Netty and Undertow. All servers are adapted to a low-level,
<a href="#webflux-httphandler">common API</a> so that higher-level
<a href="#webflux-programming-models">programming models</a> can be supported across servers.</p>
</div>
<div class="paragraph">
<p>Spring WebFlux does not have built-in support to start or stop a server. However, it is
easy to <a href="#webflux-web-handler-api">assemble</a> an application from Spring configuration and
<a href="#webflux-config">WebFlux infrastructure</a> and <a href="#webflux-httphandler">run it</a> with a few
lines of code.</p>
</div>
<div class="paragraph">
<p>Spring Boot has a WebFlux starter that automates these steps. By default, the starter uses
Netty, but it is easy to switch to Tomcat, Jetty, or Undertow by changing your
Maven or Gradle dependencies. Spring Boot defaults to Netty, because it is more widely
used in the asynchronous, non-blocking space and lets a client and a server share resources.</p>
</div>
<div class="paragraph">
<p>Tomcat and Jetty can be used with both Spring MVC and WebFlux. Keep in mind, however, that
the way they are used is very different. Spring MVC relies on Servlet blocking I/O and
lets applications use the Servlet API directly if they need to. Spring WebFlux
relies on Servlet 3.1 non-blocking I/O and uses the Servlet API behind a low-level
adapter and not exposed for direct use.</p>
</div>
<div class="paragraph">
<p>For Undertow, Spring WebFlux uses Undertow APIs directly without the Servlet API.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-performance"><a class="anchor" href="#webflux-performance"></a>1.1.6. Performance</h4>
<div class="paragraph">
<p>Performance has many characteristics and meanings. Reactive and non-blocking generally
do not make applications run faster. They can, in some cases, (for example, if using the
<code>WebClient</code> to execute remote calls in parallel). On the whole, it requires more work to do
things the non-blocking way and that can increase slightly the required processing time.</p>
</div>
<div class="paragraph">
<p>The key expected benefit of reactive and non-blocking is the ability to scale with a small,
fixed number of threads and less memory. That makes applications more resilient under load,
because they scale in a more predictable way. In order to observe those benefits, however, you
need to have some latency (including a mix of slow and unpredictable network I/O).
That is where the reactive stack begins to show its strengths, and the differences can be
dramatic.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-concurrency-model"><a class="anchor" href="#webflux-concurrency-model"></a>1.1.7. Concurrency Model</h4>
<div class="paragraph">
<p>Both Spring MVC and Spring WebFlux support annotated controllers, but there is a key
difference in the concurrency model and the default assumptions for blocking and threads.</p>
</div>
<div class="paragraph">
<p>In Spring MVC (and servlet applications in general), it is assumed that applications can
block the current thread, (for example, for remote calls), and, for this reason, servlet containers
use a large thread pool to absorb potential blocking during request handling.</p>
</div>
<div class="paragraph">
<p>In Spring WebFlux (and non-blocking servers in general), it is assumed that applications
do not block, and, therefore, non-blocking servers use  a small, fixed-size thread pool
(event loop workers) to handle requests.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
&#8220;To scale&#8221; and &#8220;small number of threads&#8221; may sound contradictory but to never block the
current thread (and rely on callbacks instead) means that you do not need extra threads, as
there are no blocking calls to absorb.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">Invoking a Blocking API</div>
<p>What if you do need to use a blocking library? Both Reactor and RxJava provide the
<code>publishOn</code> operator to continue processing on a different thread. That means there is an
easy escape hatch. Keep in mind, however, that blocking APIs are not a good fit for
this concurrency model.</p>
</div>
<div class="paragraph">
<div class="title">Mutable State</div>
<p>In Reactor and RxJava, you declare logic through operators, and, at runtime, a reactive
pipeline is formed where data is processed sequentially, in distinct stages. A key benefit
of this is that it frees applications from having to protect mutable state because
application code within that pipeline is never invoked concurrently.</p>
</div>
<div class="paragraph">
<div class="title">Threading Model</div>
<p>What threads should you expect to see on a server running with Spring WebFlux?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On a &#8220;vanilla&#8221; Spring WebFlux server (for example, no data access nor other optional
dependencies), you can expect one thread for the server and several others for request
processing (typically as many as the number of CPU cores). Servlet containers, however,
may start with more threads (for example, 10 on Tomcat), in support of both servlet (blocking) I/O
and servlet 3.1 (non-blocking) I/O usage.</p>
</li>
<li>
<p>The reactive <code>WebClient</code> operates in event loop style. So you can see a small, fixed
number of processing threads related to that (for example, <code>reactor-http-nio-</code> with the Reactor
Netty connector). However, if Reactor Netty is used for both client and server, the two
share event loop resources by default.</p>
</li>
<li>
<p>Reactor and RxJava provide thread pool abstractions, called Schedulers, to use with the
<code>publishOn</code> operator that is used to switch processing to a different thread pool.
The schedulers have names that suggest a specific concurrency strategy&#8201;&#8212;&#8201;for example, &#8220;parallel&#8221;
(for CPU-bound work with a limited number of threads) or &#8220;elastic&#8221; (for I/O-bound work with
a large number of threads). If you see such threads, it means some code is using a
specific thread pool <code>Scheduler</code> strategy.</p>
</li>
<li>
<p>Data access libraries and other third party dependencies can also create and use threads
of their own.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Configuring</div>
<p>The Spring Framework does not provide support for starting and stopping
<a href="#webflux-server-choice">servers</a>. To configure the threading model for a server, you
need to use server-specific configuration APIs, or, if you use Spring Boot, check the Spring
Boot configuration options for each server. You can <a href="#webflux-client-builder">configure</a> The <code>WebClient</code>
directly. For all other
libraries, see their respective documentation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-reactive-spring-web"><a class="anchor" href="#webflux-reactive-spring-web"></a>1.2. Reactive Core</h3>
<div class="paragraph">
<p>The <code>spring-web</code> module contains the following foundational support for reactive web
applications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For server request processing there are two levels of support.</p>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-httphandler">HttpHandler</a>: Basic contract for HTTP request handling with
non-blocking I/O and Reactive Streams back pressure, along with adapters for Reactor Netty,
Undertow, Tomcat, Jetty, and any Servlet 3.1+ container.</p>
</li>
<li>
<p><a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>: Slightly higher level, general-purpose web API for
request handling, on top of which concrete programming models such as annotated
controllers and functional endpoints are built.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For the client side, there is a basic <code>ClientHttpConnector</code> contract to perform HTTP
requests with non-blocking I/O and Reactive Streams back pressure, along with adapters for
<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a> and for the reactive
<a href="https://github.com/jetty-project/jetty-reactive-httpclient">Jetty HttpClient</a>.
The higher level <a href="#webflux-client">WebClient</a> used in applications
builds on this basic contract.</p>
</li>
<li>
<p>For client and server, <a href="#webflux-codecs">codecs</a> to use to serialize and
deserialize HTTP request and response content.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="webflux-httphandler"><a class="anchor" href="#webflux-httphandler"></a>1.2.1. <code>HttpHandler</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html">HttpHandler</a>
is a simple contract with a single method to handle a request and response. It is
intentionally minimal, and its main, and only purpose is to be a minimal abstraction
over different HTTP server APIs.</p>
</div>
<div class="paragraph">
<p>The following table describes the supported server APIs:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Server name</th>
<th class="tableblock halign-left valign-top">Server API used</th>
<th class="tableblock halign-left valign-top">Reactive Streams support</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/reactor/reactor-netty">Reactor Netty</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Undertow to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 non-blocking I/O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes server dependencies (also see
<a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework">supported versions</a>):</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Server name</th>
<th class="tableblock halign-left valign-top">Group id</th>
<th class="tableblock halign-left valign-top">Artifact name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactor Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.projectreactor.netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor-netty</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">undertow-core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.tomcat.embed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tomcat-embed-core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.eclipse.jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">jetty-server, jetty-servlet</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The code snippets below show using the <code>HttpHandler</code> adapters with each server API:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Reactor Netty</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = <span class="keyword">new</span> ReactorHttpHandlerAdapter(handler);
HttpServer.create(host, port).newHandler(adapter).block();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Undertow</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler handler = ...
UndertowHttpHandlerAdapter adapter = <span class="keyword">new</span> UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Tomcat</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler handler = ...
Servlet servlet = <span class="keyword">new</span> TomcatHttpHandlerAdapter(handler);

Tomcat server = <span class="keyword">new</span> Tomcat();
<span class="predefined-type">File</span> base = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.io.tmpdir</span><span class="delimiter">&quot;</span></span>));
<span class="predefined-type">Context</span> rootContext = server.addContext(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>, base.getAbsolutePath());
Tomcat.addServlet(rootContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>, servlet);
rootContext.addServletMappingDecoded(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>);
server.setHost(host);
server.setPort(port);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Jetty</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpHandler handler = ...
Servlet servlet = <span class="keyword">new</span> JettyHttpHandlerAdapter(handler);

Server server = <span class="keyword">new</span> Server();
ServletContextHandler contextHandler = <span class="keyword">new</span> ServletContextHandler(server, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>);
contextHandler.addServlet(<span class="keyword">new</span> ServletHolder(servlet), <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>);
contextHandler.start();

ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
connector.setHost(host);
connector.setPort(port);
server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Servlet 3.1+ Container</strong></p>
</div>
<div class="paragraph">
<p>To deploy as a WAR to any Servlet 3.1+ container, you can extend and include
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html"><code>AbstractReactiveWebInitializer</code></a>
in the WAR. That class wraps an <code>HttpHandler</code> with <code>ServletHttpHandlerAdapter</code> and registers
that as a <code>Servlet</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-web-handler-api"><a class="anchor" href="#webflux-web-handler-api"></a>1.2.2. <code>WebHandler</code> API</h4>
<div class="paragraph">
<p>The <code>org.springframework.web.server</code> package builds on the <a href="#webflux-httphandler"><code>HttpHandler</code></a> contract
to provide a general-purpose web API for processing requests through a chain of multiple
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html"><code>WebExceptionHandler</code></a>, multiple
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html"><code>WebFilter</code></a>, and a single
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html"><code>WebHandler</code></a> component. The chain can
be put together with <code>WebHttpHandlerBuilder</code> by simply pointing to a Spring
<code>ApplicationContext</code> where components are
<a href="#webflux-web-handler-api-special-beans">auto-detected</a>, and/or by registering components
with the builder.</p>
</div>
<div class="paragraph">
<p>While <code>HttpHandler</code> has a simple goal to abstract the use of different HTTP servers, the
<code>WebHandler</code> API aims to provide a broader set of features commonly used in web applications
such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>User session with attributes.</p>
</li>
<li>
<p>Request attributes.</p>
</li>
<li>
<p>Resolved <code>Locale</code> or <code>Principal</code> for the request.</p>
</li>
<li>
<p>Access to parsed and cached form data.</p>
</li>
<li>
<p>Abstractions for multipart data.</p>
</li>
<li>
<p>and more..</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="webflux-web-handler-api-special-beans"><a class="anchor" href="#webflux-web-handler-api-special-beans"></a>Special bean types</h5>
<div class="paragraph">
<p>The table below lists the components that <code>WebHttpHandlerBuilder</code> can auto-detect in a
Spring ApplicationContext, or that can be registered directly with it:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 37.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean name</th>
<th class="tableblock halign-left valign-top">Bean type</th>
<th class="tableblock halign-left valign-top">Count</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provide handling for exceptions from the chain of <code>WebFilter</code> instances and the target
  <code>WebHandler</code>. For more details, see <a href="#webflux-exception-handler">Exceptions</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply interception style logic to before and after the rest of the filter chain and
  the target <code>WebHandler</code>. For more details, see <a href="#webflux-filters">Filters</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The handler for the request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The manager for <code>WebSession</code> instances exposed through a method on <code>ServerWebExchange</code>.
  <code>DefaultWebSessionManager</code> by default.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serverCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to <code>HttpMessageReader</code> instances for parsing form data and multipart data that is then
  exposed through methods on <code>ServerWebExchange</code>. <code>ServerCodecConfigurer.create()</code> by default.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localeContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The resolver for <code>LocaleContext</code> exposed through a method on <code>ServerWebExchange</code>.
  <code>AcceptHeaderLocaleContextResolver</code> by default.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>forwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ForwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For processing forwarded type headers, either by extracting and removing them or by removing them only.
  Not used by default.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-form-data"><a class="anchor" href="#webflux-form-data"></a>Form Data</h5>
<div class="paragraph">
<p><code>ServerWebExchange</code> exposes the following method for access to form data:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono&lt;MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt;&gt; getFormData();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultServerWebExchange</code> uses the configured <code>HttpMessageReader</code> to parse form data
(<code>application/x-www-form-urlencoded</code>) into a <code>MultiValueMap</code>. By default,
<code>FormHttpMessageReader</code> is configured for use by the <code>ServerCodecConfigurer</code> bean
(see the <a href="#webflux-web-handler-api">Web Handler API</a>).</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multipart"><a class="anchor" href="#webflux-multipart"></a>Multipart Data</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multipart">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ServerWebExchange</code> exposes the following method for access to multipart data:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono&lt;MultiValueMap&lt;<span class="predefined-type">String</span>, Part&gt;&gt; getMultipartData();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultServerWebExchange</code> uses the configured
<code>HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;</code> to parse <code>multipart/form-data</code> content
into a <code>MultiValueMap</code>. At present,
<a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a> is the only
third-party library supported and the only library we know for non-blocking parsing of
multipart requests. It is enabled through the <code>ServerCodecConfigurer</code> bean
(see the <a href="#webflux-web-handler-api">Web Handler API</a>).</p>
</div>
<div class="paragraph">
<p>To parse multipart data in streaming fashion, you can use the <code>Flux&lt;Part&gt;</code> returned from an
<code>HttpMessageReader&lt;Part&gt;</code> instead. For example, in an annotated controller, use of
<code>@RequestPart</code> implies <code>Map</code>-like access to individual parts by name and, hence, requires
parsing multipart data in full. By contrast, you can use <code>@RequestBody</code> to decode the
content to <code>Flux&lt;Part&gt;</code> without collecting to a <code>MultiValueMap</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-forwarded-headers"><a class="anchor" href="#webflux-forwarded-headers"></a>Forwarded Headers</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters-forwarded-headers">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>As a request goes through proxies (such as load balancers), the host, port, and
scheme may change, and that makes it a challenge, from a client perspective, to create links that point to the correct
host, port, and scheme.</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a> defines the <code>Forwarded</code> HTTP header
that proxies can use to provide information about the original request. There are other
non-standard headers, too, including <code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>,
<code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code>, and <code>X-Forwarded-Prefix</code>.</p>
</div>
<div class="paragraph">
<p><code>ForwardedHeaderTransformer</code> is a component that modifies the host, port, and scheme of
the request, based on forwarded headers, and then removes those headers. You can declare
it as a bean with a name  of <code>forwardedHeaderTransformer</code>, and it is
<a href="#webflux-web-handler-api-special-beans">detected</a> and used.</p>
</div>
<div class="paragraph">
<p>There are security considerations for forwarded headers, since an application cannot know
if the headers were added by a proxy, as intended, or by a malicious client. This is why
a proxy at the boundary of trust should be configured to remove untrusted forwarded traffic coming
from the outside. You can also configure the <code>ForwardedHeaderTransformer</code> with
<code>removeOnly=true</code>, in which case it removes but does not use the headers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In 5.1 <code>ForwardedHeaderFilter</code> was deprecated and superceded by
<code>ForwardedHeaderTransformer</code> so forwarded headers can be processed earlier, before the
exchange is created. If the filter is configured anyway, it is taken out of the list of
filters, and <code>ForwardedHeaderTransformer</code> is used instead.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-filters"><a class="anchor" href="#webflux-filters"></a>1.2.3. Filters</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>In the <a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>, you can use a <code>WebFilter</code> to apply interception-style
logic before and after the rest of the processing chain of filters and the target
<code>WebHandler</code>. When using the <a href="#webflux-config">WebFlux Config</a>, registering a <code>WebFilter</code> is as simple
as declaring it as a Spring bean and (optionally) expressing precedence by using <code>@Order</code> on
the bean declaration or by implementing <code>Ordered</code>.</p>
</div>
<div class="sect4">
<h5 id="webflux-filters-cors"><a class="anchor" href="#webflux-filters-cors"></a>CORS</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters-cors">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux provides fine-grained support for CORS configuration through annotations on
controllers. However, when you use it with Spring Security, we advise relying on the built-in
<code>CorsFilter</code>, which must be ordered ahead of Spring Security&#8217;s chain of filters.</p>
</div>
<div class="paragraph">
<p>See the section on <a href="#webflux-cors">CORS</a> and the <a href="#webflux-cors-webfilter">CORS <code>WebFilter</code></a> for more details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-exception-handler"><a class="anchor" href="#webflux-exception-handler"></a>1.2.4. Exceptions</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-customer-servlet-container-error-page">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>In the <a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>, you can use a <code>WebExceptionHandler</code> to handle
exceptions from the chain of <code>WebFilter</code> instances and the target <code>WebHandler</code>. When using the
<a href="#webflux-config">WebFlux Config</a>, registering a <code>WebExceptionHandler</code> is as simple as declaring it as a
Spring bean and (optionally) expressing precedence by using <code>@Order</code> on the bean declaration or
by implementing <code>Ordered</code>.</p>
</div>
<div class="paragraph">
<p>The following table describes the available <code>WebExceptionHandler</code> implementations:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Exception Handler</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides handling for exceptions of type
  <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/server/ResponseStatusException.html"><code>ResponseStatusException</code></a>
  by setting the response to the HTTP status code of the exception.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFluxResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extension of <code>ResponseStatusExceptionHandler</code> that can also determine the HTTP status
  code of a <code>@ResponseStatus</code> annotation on any exception.
</p><p class="tableblock">  This handler is declared in the <a href="#webflux-config">WebFlux Config</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-codecs"><a class="anchor" href="#webflux-codecs"></a>1.2.5. Codecs</h4>
<div class="paragraph">
<p><span class="small"><a href="integration.html#rest-message-conversion">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>spring-web</code> and <code>spring-core</code> modules provide support for serializing and
deserializing byte content to and from higher level objects through non-blocking I/O with
Reactive Streams back pressure. The following describes this support:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html"><code>Encoder</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html"><code>Decoder</code></a> are low level contracts to
encode and decode content independent of HTTP.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html"><code>HttpMessageReader</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html"><code>HttpMessageWriter</code></a> are contracts
to encode and decode HTTP message content.</p>
</li>
<li>
<p>An <code>Encoder</code> can be wrapped with <code>EncoderHttpMessageWriter</code> to adapt it for use in a web
application, while a <code>Decoder</code> can be wrapped with <code>DecoderHttpMessageReader</code>.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html"><code>DataBuffer</code></a> abstracts different
byte buffer representations (e.g. Netty <code>ByteBuf</code>, <code>java.nio.ByteBuffer</code>, etc.) and is
what all codecs work on. See <a href="core.html#databuffers">Data Buffers and Codecs</a> in the
"Spring Core" section for more on this topic.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>spring-core</code> module provides <code>byte[]</code>, <code>ByteBuffer</code>, <code>DataBuffer</code>, <code>Resource</code>, and
<code>String</code> encoder and decoder implementations. The <code>spring-web</code> module provides Jackson
JSON, Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders along with
web-only HTTP message reader and writer implementations for form data, multipart content,
server-sent events, and others.</p>
</div>
<div class="paragraph">
<p><code>ClientCodecConfigurer</code> and <code>ServerCodecConfigurer</code> are typically used to configure and
customize the codecs to use in an application. See the section on configuring
<a href="#webflux-config-message-codecs">HTTP message codecs</a>.</p>
</div>
<div class="sect4">
<h5 id="webflux-codecs-jackson"><a class="anchor" href="#webflux-codecs-jackson"></a>Jackson JSON</h5>
<div class="paragraph">
<p>JSON and binary JSON (<a href="https://github.com/FasterXML/smile-format-specification">Smile</a>) are
both supported when the Jackson library is present.</p>
</div>
<div class="paragraph">
<p>The <code>Jackson2Decoder</code> works as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jackson&#8217;s asynchronous, non-blocking parser is used to aggregate a stream of byte chunks
into <code>TokenBuffer</code>'s each representing a JSON object.</p>
</li>
<li>
<p>Each <code>TokenBuffer</code> is passed to Jackson&#8217;s <code>ObjectMapper</code> to create a higher level object.</p>
</li>
<li>
<p>When decoding to a single-value publisher (e.g. <code>Mono</code>), there is one <code>TokenBuffer</code>.</p>
</li>
<li>
<p>When decoding to a multi-value publisher (e.g. <code>Flux</code>), each <code>TokenBuffer</code> is passed to
the <code>ObjectMapper</code> as soon as enough bytes are received for a fully formed object. The
input content can be a JSON array, or
<a href="https://en.wikipedia.org/wiki/JSON_streaming">line-delimited JSON</a> if the content-type is
"application/stream+json".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>Jackson2Encoder</code> works as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For a single value publisher (e.g. <code>Mono</code>), simply serialize it through the
<code>ObjectMapper</code>.</p>
</li>
<li>
<p>For a multi-value publisher with "application/json", by default collect the values with
<code>Flux#collectToList()</code> and then serialize the resulting collection.</p>
</li>
<li>
<p>For a multi-value publisher with a streaming media type such as
<code>application/stream+json</code> or <code>application/stream+x-jackson-smile</code>, encode, write, and
flush each value individually using a
<a href="https://en.wikipedia.org/wiki/JSON_streaming">line-delimited JSON</a> format.</p>
</li>
<li>
<p>For SSE the <code>Jackson2Encoder</code> is invoked per event and the output is flushed to ensure
delivery without delay.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default both <code>Jackson2Encoder</code> and <code>Jackson2Decoder</code> do not support elements of type
<code>String</code>. Instead the default assumption is that a string or a sequence of strings
represent serialized JSON content, to be rendered by the <code>CharSequenceEncoder</code>. If what
you need is to render a JSON array from <code>Flux&lt;String&gt;</code>, use <code>Flux#collectToList()</code> and
encode a <code>Mono&lt;List&lt;String&gt;&gt;</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-forms"><a class="anchor" href="#webflux-codecs-forms"></a>Form Data</h5>
<div class="paragraph">
<p><code>FormHttpMessageReader</code> and <code>FormHttpMessageWriter</code> support decoding and encoding
"application/x-www-form-urlencoded" content.</p>
</div>
<div class="paragraph">
<p>On the server side where form content often needs to be accessed from multiple places,
<code>ServerWebExchange</code> provides a dedicated <code>getFormData()</code> method that parses the content
through <code>FormHttpMessageReader</code> and then caches the result for repeated access.
See <a href="#webflux-form-data">Form Data</a> in the <a href="#webflux-web-handler-api"><code>WebHandler</code> API</a> section.</p>
</div>
<div class="paragraph">
<p>Once <code>getFormData()</code> is used, the original raw content can no longer be read from the
request body. For this reason, applications are expected to go through <code>ServerWebExchange</code>
consistently for access to the cached form data versus reading from the raw request body.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-multipart"><a class="anchor" href="#webflux-codecs-multipart"></a>Multipart</h5>
<div class="paragraph">
<p><code>MultipartHttpMessageReader</code> and <code>MultipartHttpMessageWriter</code> support decoding and
encoding "multipart/form-data" content. In turn <code>MultipartHttpMessageReader</code> delegates to
another <code>HttpMessageReader</code> for the actual parsing to a <code>Flux&lt;Part&gt;</code> and then simply
collects the parts into a <code>MultiValueMap</code>. At present the
<a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a> is used for the
actual parsing.</p>
</div>
<div class="paragraph">
<p>On the server side where multipart form content may need to be accessed from multiple
places, <code>ServerWebExchange</code> provides a dedicated <code>getMultipartData()</code> method that parses
the content through <code>MultipartHttpMessageReader</code> and then caches the result for repeated access.
See <a href="#webflux-multipart">Multipart Data</a> in the <a href="#webflux-web-handler-api"><code>WebHandler</code> API</a> section.</p>
</div>
<div class="paragraph">
<p>Once <code>getMultipartData()</code> is used, the original raw content can no longer be read from the
request body. For this reason applications have to consistently use <code>getMultipartData()</code>
for repeated, map-like access to parts, or otherwise rely on the
<code>SynchronossPartHttpMessageReader</code> for a one-time access to <code>Flux&lt;Part&gt;</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-streaming"><a class="anchor" href="#webflux-codecs-streaming"></a>Streaming</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-async-http-streaming">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>When streaming to the HTTP response (for example, <code>text/event-stream</code>,
<code>application/stream+json</code>), it is important to send data periodically, in order to
reliably detect a disconnected client sooner rather than later. Such a send could be an
comment-only, empty SSE event or any other "no-op" data that would effectively serve as
a heartbeat.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-buffers"><a class="anchor" href="#webflux-codecs-buffers"></a><code>DataBuffer</code></h5>
<div class="paragraph">
<p><code>DataBuffer</code> is the representation for a byte buffer in WebFlux. The Spring Core part of
the reference has more on that in the section on
<a href="core.html#databuffers">Data Buffers and Codecs</a>. The key point to understand is that on some
servers like Netty, byte buffers are pooled and reference counted, and must be released
when consumed to avoid memory leaks.</p>
</div>
<div class="paragraph">
<p>WebFlux applications generally do not need to be concerned with such issues, unless they
consume or produce data buffers directly, as opposed to relying on codecs to convert to
and from higher level objects. Or unless they choose to create custom codecs. For such
cases please review the the information in <a href="core.html#databuffers">Data Buffers and Codecs</a>,
especially the section on <a href="core.html#databuffers-using">Using DataBuffer</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-logging"><a class="anchor" href="#webflux-logging"></a>1.2.6. Logging</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-logging">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>DEBUG level logging in Spring WebFlux is designed to be compact, minimal, and
human-friendly. It focuses on high value bits of information that are useful over and
over again vs others that are useful only when debugging a specific issue.</p>
</div>
<div class="paragraph">
<p>TRACE level logging generally follows the same principles as DEBUG (and for example also
should not be a firehose) but can be used for debugging any issue. In addition some log
messages may show a different level of detail at TRACE vs DEBUG.</p>
</div>
<div class="paragraph">
<p>Good logging comes from the experience of using the logs. If you spot anything that does
not meet the stated goals, please let us know.</p>
</div>
<div class="sect4">
<h5 id="webflux-logging-id"><a class="anchor" href="#webflux-logging-id"></a>Log Id</h5>
<div class="paragraph">
<p>In WebFlux, a single request can be executed over multiple threads and the thread ID
is not useful for correlating log messages that belong to a specific request. This is why
WebFlux log messages are prefixed with a request-specific ID by default.</p>
</div>
<div class="paragraph">
<p>On the server side, the log ID is stored in the <code>ServerWebExchange</code> attribute
(<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a>),
while a fully formatted prefix based on that ID is available from
<code>ServerWebExchange#getLogPrefix()</code>. On the <code>WebClient</code> side, the log ID is stored in the
<code>ClientRequest</code> attribute
(<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a>)
,while a fully formatted prefix is available from <code>ClientRequest#logPrefix()</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-logging-sensitive-data"><a class="anchor" href="#webflux-logging-sensitive-data"></a>Sensitive Data</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-logging-sensitive-data">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>DEBUG</code> and <code>TRACE</code> logging can log sensitive information. This is why form parameters and
headers are masked by default and you must explicitly enable their logging in full.</p>
</div>
<div class="paragraph">
<p>The followig example shows how to do so for server-side requests:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="type">class</span> <span class="class">MyConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().enableLoggingRequestDetails(<span class="predefined-constant">true</span>);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to do so for client-side requests:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Consumer&lt;ClientCodecConfigurer&gt; consumer = configurer -&gt;
        configurer.defaultCodecs().enableLoggingRequestDetails(<span class="predefined-constant">true</span>);

WebClient webClient = WebClient.builder()
        .exchangeStrategies(ExchangeStrategies.builder().codecs(consumer).build())
        .build();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-dispatcher-handler"><a class="anchor" href="#webflux-dispatcher-handler"></a>1.3. <code>DispatcherHandler</code></h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux, similarly to Spring MVC, is designed around the front controller pattern, where a
central <code>WebHandler</code>, the <code>DispatcherHandler</code>, provides a shared algorithm for request
processing, while actual work is performed by configurable, delegate components.
This model is flexible and supports diverse workflows.</p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> discovers the delegate components it needs from Spring configuration.
It is also designed to be a Spring bean itself and implements <code>ApplicationContextAware</code>
for access to the context in which it runs. If <code>DispatcherHandler</code> is declared with a bean
name of <code>webHandler</code>, it is, in turn, discovered by
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html"><code>WebHttpHandlerBuilder</code></a>,
which puts together a request-processing chain, as described in
<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>.</p>
</div>
<div class="paragraph">
<p>Spring configuration in a WebFlux application typically contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DispatcherHandler</code> with the bean name, <code>webHandler</code></p>
</li>
<li>
<p><code>WebFilter</code> and <code>WebExceptionHandler</code> beans</p>
</li>
<li>
<p><a href="#webflux-special-bean-types"><code>DispatcherHandler</code> special beans</a></p>
</li>
<li>
<p>Others</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The configuration is given to <code>WebHttpHandlerBuilder</code> to build the processing chain,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The resulting <code>HttpHandler</code> is ready for use with a
<a href="#webflux-httphandler">server adapter</a>.</p>
</div>
<div class="sect3">
<h4 id="webflux-special-bean-types"><a class="anchor" href="#webflux-special-bean-types"></a>1.3.1. Special Bean Types</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-special-bean-types">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>DispatcherHandler</code> delegates to special beans to process requests and render the
appropriate responses. By &#8220;special beans,&#8221; we mean Spring-managed <code>Object</code> instances that
implement WebFlux framework contracts. Those usually come with built-in contracts, but
you can customize their properties, extend them, or replace them.</p>
</div>
<div class="paragraph">
<p>The following table lists the special beans detected by the <code>DispatcherHandler</code>. Note that
there are also some other beans detected at a lower level (see
<a href="#webflux-web-handler-api-special-beans">Special bean types</a> in the Web Handler API).</p>
</div>
<table id="webflux-special-beans-table" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean type</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMapping</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map a request to a handler. The mapping is based on some criteria, the details of
  which vary by <code>HandlerMapping</code> implementation&#8201;&#8212;&#8201;annotated controllers, simple
  URL pattern mappings, and others.
</p><p class="tableblock">  The main <code>HandlerMapping</code> implementations are <code>RequestMappingHandlerMapping</code> for
  <code>@RequestMapping</code> annotated methods, <code>RouterFunctionMapping</code> for functional endpoint
  routes, and <code>SimpleUrlHandlerMapping</code> for explicit registrations of URI path patterns
  and <code>WebHandler</code> instances.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerAdapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Help the <code>DispatcherHandler</code> to invoke a handler mapped to a request regardless of
  how the handler is actually invoked. For example, invoking an annotated controller
  requires resolving annotations. The main purpose of a <code>HandlerAdapter</code> is to shield the
  <code>DispatcherHandler</code> from such details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process the result from the handler invocation and finalize the response.
  See <a href="#webflux-resulthandling">Result Handling</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-framework-config"><a class="anchor" href="#webflux-framework-config"></a>1.3.2. WebFlux Config</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-config">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Applications can declare the infrastructure beans (listed under
<a href="#webflux-web-handler-api-special-beans">Web Handler API</a> and
<a href="#webflux-special-bean-types"><code>DispatcherHandler</code></a>) that are required to process requests.
However, in most cases, the <a href="#webflux-config">WebFlux Config</a> is the best starting point. It declares the
required beans and provides a higher-level configuration callback API to customize it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot relies on the WebFlux config to configure Spring WebFlux and also provides
many extra convenient options.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-handler-sequence"><a class="anchor" href="#webflux-dispatcher-handler-sequence"></a>1.3.3. Processing</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-sequence">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> processes requests as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each <code>HandlerMapping</code> is asked to find a matching handler, and the first match is used.</p>
</li>
<li>
<p>If a handler is found, it is executed through an appropriate <code>HandlerAdapter</code>, which
exposes the return value from the execution as <code>HandlerResult</code>.</p>
</li>
<li>
<p>The <code>HandlerResult</code> is given to an appropriate <code>HandlerResultHandler</code> to complete
processing by writing to the response directly or by using a view to render.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-resulthandling"><a class="anchor" href="#webflux-resulthandling"></a>1.3.4. Result Handling</h4>
<div class="paragraph">
<p>The return value from the invocation of a handler, through a <code>HandlerAdapter</code>, is wrapped
as a <code>HandlerResult</code>, along with some additional context, and passed to the first
<code>HandlerResultHandler</code> that claims support for it. The following table shows the available
<code>HandlerResultHandler</code> implementations, all of which are declared in the <a href="#webflux-config">WebFlux Config</a>:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Result Handler Type</th>
<th class="tableblock halign-left valign-top">Return Values</th>
<th class="tableblock halign-left valign-top">Default Order</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntityResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntity</code>, typically from <code>@Controller</code> instances.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponseResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponse</code>, typically from functional endpoints.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseBodyResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handle return values from <code>@ResponseBody</code> methods or <code>@RestController</code> classes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ViewResolutionResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CharSequence</code>, <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/View.html"><code>View</code></a>,
  <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/ui/Model.html">Model</a>, <code>Map</code>,
  <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">Rendering</a>,
  or any other <code>Object</code> is treated as a model attribute.
</p><p class="tableblock">  See also <a href="#webflux-viewresolution">View Resolution</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Integer.MAX_VALUE</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-exceptions"><a class="anchor" href="#webflux-dispatcher-exceptions"></a>1.3.5. Exceptions</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-exceptionhandlers">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>HandlerResult</code> returned from a <code>HandlerAdapter</code> can expose a function for error
handling based on some handler-specific mechanism. This error function is called if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The handler (for example, <code>@Controller</code>) invocation fails.</p>
</li>
<li>
<p>The handling of the handler return value through a <code>HandlerResultHandler</code> fails.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The error function can change the response (for example, to an error status), as long as an error
signal occurs before the reactive type returned from the handler produces any data items.</p>
</div>
<div class="paragraph">
<p>This is how <code>@ExceptionHandler</code> methods in <code>@Controller</code> classes are supported.
By contrast, support for the same in Spring MVC is built on a <code>HandlerExceptionResolver</code>.
This generally should not matter. However, keep in mind that, in WebFlux, you cannot use a
<code>@ControllerAdvice</code> to handle exceptions that occur before a handler is chosen.</p>
</div>
<div class="paragraph">
<p>See also <a href="#webflux-ann-controller-exceptions">Managing Exceptions</a> in the &#8220;Annotated Controller&#8221; section or
<a href="#webflux-exception-handler">Exceptions</a> in the WebHandler API section.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-viewresolution"><a class="anchor" href="#webflux-viewresolution"></a>1.3.6. View Resolution</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-viewresolver">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>View resolution enables rendering to a browser with an HTML template and a model without
tying you to a specific view technology. In Spring WebFlux, view resolution is
supported through a dedicated <a href="#webflux-resulthandling">HandlerResultHandler</a> that uses
  <code>ViewResolver</code> instances to map a String (representing a logical view name) to a <code>View</code>
instance. The <code>View</code> is then used to render the response.</p>
</div>
<div class="sect4">
<h5 id="webflux-viewresolution-handling"><a class="anchor" href="#webflux-viewresolution-handling"></a>Handling</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-handling">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>HandlerResult</code> passed into <code>ViewResolutionResultHandler</code> contains the return value
from the handler and the model that contains attributes added during request
handling. The return value is processed as one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String</code>, <code>CharSequence</code>: A logical view name to be resolved to a <code>View</code> through
the list of configured <code>ViewResolver</code> implementations.</p>
</li>
<li>
<p><code>void</code>: Select a default view name based on the request path, minus the leading and
trailing slash, and resolve it to a <code>View</code>. The same also happens when a view name
was not provided (for example, model attribute was returned) or an async return value
(for example, <code>Mono</code> completed empty).</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">Rendering</a>: API for
view resolution scenarios. Explore the options in your IDE with code completion.</p>
</li>
<li>
<p><code>Model</code>, <code>Map</code>: Extra model attributes to be added to the model for the request.</p>
</li>
<li>
<p>Any other: Any other return value (except for simple types, as determined by
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>)
is treated as a model attribute to be added to the model. The attribute name is derived
from the class name by using <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/core/Conventions.html">conventions</a>,
unless a handler method <code>@ModelAttribute</code> annotation is present.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The model can contain asynchronous, reactive types (for example, from Reactor or RxJava). Prior
to rendering, <code>AbstractView</code> resolves such model attributes into concrete values
and updates the model. Single-value reactive types are resolved to a single
value or no value (if empty), while multi-value reactive types (for example, <code>Flux&lt;T&gt;</code>) are
collected and resolved to <code>List&lt;T&gt;</code>.</p>
</div>
<div class="paragraph">
<p>To configure view resolution is as simple as adding a <code>ViewResolutionResultHandler</code> bean
to your Spring configuration. <a href="#webflux-config-view-resolvers">WebFlux Config</a> provides a
dedicated configuration API for view resolution.</p>
</div>
<div class="paragraph">
<p>See <a href="#webflux-view">View Technologies</a> for more on the view technologies integrated with Spring WebFlux.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-redirecting-redirect-prefix"><a class="anchor" href="#webflux-redirecting-redirect-prefix"></a>Redirecting</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-redirecting-redirect-prefix">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The special <code>redirect:</code> prefix in a view name lets you perform a redirect. The
<code>UrlBasedViewResolver</code> (and sub-classes) recognize this as an instruction that a
redirect is needed. The rest of the view name is the redirect URL.</p>
</div>
<div class="paragraph">
<p>The net effect is the same as if the controller had returned a <code>RedirectView</code> or
<code>Rendering.redirectTo("abc").build()</code>, but now the controller itself can
operate in terms of logical view names. A view name such as
<code>redirect:/some/resource</code> is relative to the current application, while a view name such as
<code>redirect:http://example.com/arbitrary/path</code> redirects to an absolute URL.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multiple-representations"><a class="anchor" href="#webflux-multiple-representations"></a>Content Negotiation</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multiple-representations">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ViewResolutionResultHandler</code> supports content negotiation. It compares the request
media types with the media types supported by each selected <code>View</code>. The first <code>View</code>
that supports the requested media type(s) is used.</p>
</div>
<div class="paragraph">
<p>In order to support media types such as JSON and XML, Spring WebFlux provides
<code>HttpMessageWriterView</code>, which is a special <code>View</code> that renders through an
<a href="#webflux-codecs">HttpMessageWriter</a>. Typically, you would configure these as default
views through the <a href="#webflux-config-view-resolvers">WebFlux Configuration</a>. Default views are
always selected and used if they match the requested media type.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-controller"><a class="anchor" href="#webflux-controller"></a>1.4. Annotated Controllers</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-controller">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux provides an annotation-based programming model, where <code>@Controller</code> and
<code>@RestController</code> components use annotations to express request mappings, request input,
handle exceptions, and more. Annotated controllers have flexible method signatures and
do not have to extend base classes nor implement specific interfaces.</p>
</div>
<div class="paragraph">
<p>The following listing shows a basic example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">HelloController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/hello</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">String</span> handle() {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello WebFlux</span><span class="delimiter">&quot;</span></span>;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the method returns a <code>String</code> to be written to the response body.</p>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller"><a class="anchor" href="#webflux-ann-controller"></a>1.4.1. <code>@Controller</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-controller">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can define controller beans by using a standard Spring bean definition.
The <code>@Controller</code> stereotype allows for auto-detection and is aligned with Spring general support
for detecting <code>@Component</code> classes in the classpath and auto-registering bean definitions
for them. It also acts as a stereotype for the annotated class, indicating its role as
a web component.</p>
</div>
<div class="paragraph">
<p>To enable auto-detection of such <code>@Controller</code> beans, you can add component scanning to
your Java configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.web</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> {

    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Scan the <code>org.example.web</code> package.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@RestController</code> is a <a href="core.html#beans-meta-annotations">composed annotation</a> that is
itself meta-annotated with <code>@Controller</code> and <code>@ResponseBody</code>, indicating a controller whose
every method inherits the type-level <code>@ResponseBody</code> annotation and, therefore, writes
directly to the response body versus view resolution and rendering with an HTML template.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping"><a class="anchor" href="#webflux-ann-requestmapping"></a>1.4.2. Request Mapping</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>@RequestMapping</code> annotation is used to map requests to controllers methods. It has
various attributes to match by URL, HTTP method, request parameters, headers, and media
types. You can use it at the class level to express shared mappings or at the method level
to narrow down to a specific endpoint mapping.</p>
</div>
<div class="paragraph">
<p>There are also HTTP method specific shortcut variants of <code>@RequestMapping</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The preceding annotations are <a href="#webflux-ann-requestmapping-composed">Custom Annotations</a> that are provided
because, arguably, most controller methods should be mapped to a specific HTTP method versus
using <code>@RequestMapping</code>, which, by default, matches to all HTTP methods. At the same time, a
<code>@RequestMapping</code> is still needed at the class level to express shared mappings.</p>
</div>
<div class="paragraph">
<p>The following example uses type and method level mappings:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">PersonController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Person getPerson(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@PostMapping</span>
    <span class="annotation">@ResponseStatus</span>(HttpStatus.CREATED)
    <span class="directive">public</span> <span class="type">void</span> add(<span class="annotation">@RequestBody</span> Person person) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-uri-templates"><a class="anchor" href="#webflux-ann-requestmapping-uri-templates"></a>URI Patterns</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-uri-templates">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can map requests by using glob patterns and wildcards:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>?</code> matches one character</p>
</li>
<li>
<p><code>*</code> matches zero or more characters within a path segment</p>
</li>
<li>
<p><code>**</code> match zero or more path segments</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also declare URI variables and access their values with <code>@PathVariable</code>,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}/pets/{petId}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> Pet findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> ownerId, <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> petId) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can declare URI variables at the class and method levels, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">public</span> <span class="type">class</span> <span class="class">OwnerController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{petId}</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">public</span> Pet findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> ownerId, <span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> petId) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Class-level URI mapping.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Method-level URI mapping.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>URI variables are automatically converted to the appropriate type or a <code>TypeMismatchException</code>
is raised. Simple types (<code>int</code>, <code>long</code>, <code>Date</code>, and so on) are supported by default and you can
register support for any other data type.
See <a href="#webflux-ann-typeconversion">Type Conversion</a> and <a href="#webflux-ann-initbinder"><code>DataBinder</code></a>.</p>
</div>
<div class="paragraph">
<p>URI variables can be named explicitly (for example, <code>@PathVariable("customId")</code>), but you can
leave that detail out if the names are the same and you compile your code with debugging
information or with the <code>-parameters</code> compiler flag on Java 8.</p>
</div>
<div class="paragraph">
<p>The syntax <code>{*varName}</code> declares a URI variable that matches zero or more remaining
path segments. For example <code>/resources/{*path}</code> matches all files <code>/resources/</code> and the
<code>"path"</code> variable captures the complete relative path.</p>
</div>
<div class="paragraph">
<p>The syntax <code>{varName:regex}</code> declares a URI variable with a regular expression that has the
syntax: <code>{varName:regex}</code>. For example, given a URL of <code>/spring-web-3.0.5 .jar</code>, the following method
extracts the name, version, and file extension:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{name:[a-z-]+}-{version:</span><span class="char">\\</span><span class="content">d</span><span class="char">\\</span><span class="content">.</span><span class="char">\\</span><span class="content">d</span><span class="char">\\</span><span class="content">.</span><span class="char">\\</span><span class="content">d}{ext:</span><span class="char">\\</span><span class="content">.[a-z]+}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> version, <span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> ext) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>URI path patterns can also have embedded <code>${&#8230;&#8203;}</code> placeholders that are resolved on startup
through <code>PropertyPlaceHolderConfigurer</code> against local, system, environment, and other property
sources. You ca use this to, for example, parameterize a base URL based on some external
configuration.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring WebFlux uses <code>PathPattern</code> and the <code>PathPatternParser</code> for URI path matching support.
Both classes are located in <code>spring-web</code> and are expressly designed for use with HTTP URL
paths in web applications where a large number of URI path patterns are matched at runtime.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring WebFlux does not support suffix pattern matching&#8201;&#8212;&#8201;unlike Spring MVC, where a
mapping such as <code>/person</code> also matches to <code>/person.*</code>. For URL-based content
negotiation, if needed, we recommend using a query parameter, which is simpler, more
explicit, and less vulnerable to URL path based exploits.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-pattern-comparison"><a class="anchor" href="#webflux-ann-requestmapping-pattern-comparison"></a>Pattern Comparison</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-pattern-comparison">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>When multiple patterns match a URL, they must be compared to find the best match. This is done
with <code>PathPattern.SPECIFICITY_COMPARATOR</code>, which looks for patterns that are more specific.</p>
</div>
<div class="paragraph">
<p>For every pattern, a score is computed, based on the number of URI variables and wildcards,
where a URI variable scores lower than a wildcard. A pattern with a lower total score
wins. If two patterns have the same score, the longer is chosen.</p>
</div>
<div class="paragraph">
<p>Catch-all patterns (for example, <code>**</code>, <code>{*varName}</code>) are excluded from the scoring and are always
sorted last instead. If two patterns are both catch-all, the longer is chosen.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-consumes"><a class="anchor" href="#webflux-ann-requestmapping-consumes"></a>Consumable Media Types</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-consumes">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow the request mapping based on the <code>Content-Type</code> of the request,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(path = <span class="string"><span class="delimiter">&quot;</span><span class="content">/pets</span><span class="delimiter">&quot;</span></span>, <strong>consumes = <span class="string"><span class="delimiter">&quot;</span><span class="content">application/json</span><span class="delimiter">&quot;</span></span></strong>)
<span class="directive">public</span> <span class="type">void</span> addPet(<span class="annotation">@RequestBody</span> Pet pet) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The consumes attribute also supports negation expressions&#8201;&#8212;&#8201;for example, <code>!text/plain</code> means any
content type other than <code>text/plain</code>.</p>
</div>
<div class="paragraph">
<p>You can declare a shared <code>consumes</code> attribute at the class level. Unlike most other request
mapping attributes, however, when used at the class level, a method-level <code>consumes</code> attribute
overrides rather than extends the class-level declaration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MediaType</code> provides constants for commonly used media types&#8201;&#8212;&#8201;for example,
<code>APPLICATION_JSON_VALUE</code> and <code>APPLICATION_XML_VALUE</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-produces"><a class="anchor" href="#webflux-ann-requestmapping-produces"></a>Producible Media Types</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-produces">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow the request mapping based on the <code>Accept</code> request header and the list of
content types that a controller method produces, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(path = <span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{petId}</span><span class="delimiter">&quot;</span></span>, <strong>produces = <span class="string"><span class="delimiter">&quot;</span><span class="content">application/json;charset=UTF-8</span><span class="delimiter">&quot;</span></span></strong>)
<span class="annotation">@ResponseBody</span>
<span class="directive">public</span> Pet getPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The media type can specify a character set. Negated expressions are supported&#8201;&#8212;&#8201;for example,
<code>!text/plain</code> means any content type other than <code>text/plain</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For JSON content type, you should specify the UTF-8 <code>charset</code> even if
<a href="https://tools.ietf.org/html/rfc7159#section-11">RFC7159</a>
clearly states that &#8220;no charset parameter is defined for this registration,&#8221; because some
browsers require it to correctly interpret UTF-8 special characters.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can declare a shared <code>produces</code> attribute at the class level. Unlike most other request
mapping attributes, however, when used at the class level, a method-level <code>produces</code> attribute
overrides rather than extend the class level declaration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MediaType</code> provides constants for commonly used media types&#8201;&#8212;&#8201;e.g.
<code>APPLICATION_JSON_UTF8_VALUE</code>, <code>APPLICATION_XML_VALUE</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-params-and-headers"><a class="anchor" href="#webflux-ann-requestmapping-params-and-headers"></a>Parameters and Headers</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-params-and-headers">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can narrow request mappings based on query parameter conditions. You can test for the
presence of a query parameter (<code>myParam</code>), for its absence (<code>!myParam</code>), or for a
specific value (<code>myParam=myValue</code>). The following examples tests for a parameter with a value:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(path = <span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{petId}</span><span class="delimiter">&quot;</span></span>, params = <span class="string"><span class="delimiter">&quot;</span><span class="content">myParam=myValue</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">public</span> <span class="type">void</span> findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Check that <code>myParam</code> equals <code>myValue</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use the same with request header conditions, as the follwing example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(path = <span class="string"><span class="delimiter">&quot;</span><span class="content">/pets</span><span class="delimiter">&quot;</span></span>, headers = <span class="string"><span class="delimiter">&quot;</span><span class="content">myHeader=myValue</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">public</span> <span class="type">void</span> findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Check that <code>myHeader</code> equals <code>myValue</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-head-options"><a class="anchor" href="#webflux-ann-requestmapping-head-options"></a>HTTP HEAD, OPTIONS</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-head-options">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> and <code>@RequestMapping(method=HttpMethod.GET)</code> support HTTP HEAD
transparently for request mapping purposes. Controller methods need not change.
A response wrapper, applied in the <code>HttpHandler</code> server adapter, ensures a <code>Content-Length</code>
header is set to the number of bytes written without actually writing to the response.</p>
</div>
<div class="paragraph">
<p>By default, HTTP OPTIONS is handled by setting the <code>Allow</code> response header to the list of HTTP
methods listed in all <code>@RequestMapping</code> methods with matching URL patterns.</p>
</div>
<div class="paragraph">
<p>For a <code>@RequestMapping</code> without HTTP method declarations, the <code>Allow</code> header is set to
<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>. Controller methods should always declare the
supported HTTP methods (for example, by using the HTTP method specific variants&#8201;&#8212;&#8201;<code>@GetMapping</code>, <code>@PostMapping</code>, and others).</p>
</div>
<div class="paragraph">
<p>You can explicitly map a <code>@RequestMapping</code> method to HTTP HEAD and HTTP OPTIONS, but that
is not necessary in the common case.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-composed"><a class="anchor" href="#webflux-ann-requestmapping-composed"></a>Custom Annotations</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-composed">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux supports the use of <a href="core.html#beans-meta-annotations">composed annotations</a>
for request mapping. Those are annotations that are themselves meta-annotated with
<code>@RequestMapping</code> and composed to redeclare a subset (or all) of the <code>@RequestMapping</code>
attributes with a narrower, more specific purpose.</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, and <code>@PatchMapping</code> are
examples of composed annotations. They are provided, because, arguably, most
controller methods should be mapped to a specific HTTP method versus using <code>@RequestMapping</code>,
which, by default, matches to all HTTP methods. If you need an example of composed
annotations, look at how those are declared.</p>
</div>
<div class="paragraph">
<p>Spring WebFlux also supports custom request mapping attributes with custom request matching
logic. This is a more advanced option that requires sub-classing
<code>RequestMappingHandlerMapping</code> and overriding the <code>getCustomMethodCondition</code> method, where
you can check the custom attribute and return your own <code>RequestCondition</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-registration"><a class="anchor" href="#webflux-ann-requestmapping-registration"></a>Explicit Registrations</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-registration">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can programmatically register Handler methods, which can be used for dynamic
registrations or for advanced cases, such as different instances of the same handler
under different URLs. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfig</span> {

    <span class="annotation">@Autowired</span>
    <span class="directive">public</span> <span class="type">void</span> setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="directive">throws</span> <span class="exception">NoSuchMethodException</span> {

        RequestMappingInfo info = RequestMappingInfo
                .paths(<span class="string"><span class="delimiter">&quot;</span><span class="content">/user/{id}</span><span class="delimiter">&quot;</span></span>).methods(RequestMethod.GET).build(); <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="predefined-type">Method</span> method = UserHandler.class.getMethod(<span class="string"><span class="delimiter">&quot;</span><span class="content">getUser</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Long</span>.class); <i class="conum" data-value="3"></i><b>(3)</b>

        mapping.registerMapping(info, handler, method); <i class="conum" data-value="4"></i><b>(4)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject target handlers and the handler mapping for controllers.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Prepare the request mapping metadata.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get the handler method.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Add the registration.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-methods"><a class="anchor" href="#webflux-ann-methods"></a>1.4.3. Handler Methods</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-methods">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> handler methods have a flexible signature and can choose from a range of
supported controller method arguments and return values.</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-arguments"><a class="anchor" href="#webflux-ann-arguments"></a>Method Arguments</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-arguments">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following table shows the supported controller method arguments.</p>
</div>
<div class="paragraph">
<p>Reactive types (Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a>) are
supported on arguments that require blocking I/O (for example, reading the request body) to
be resolved. This is marked in the Description column. Reactive types are not expected
on arguments that do not require blocking.</p>
</div>
<div class="paragraph">
<p>JDK 1.8&#8217;s <code>java.util.Optional</code> is supported as a method argument in combination with
annotations that have a <code>required</code> attribute (for example, <code>@RequestParam</code>, <code>@RequestHeader</code>,
and others) and is equivalent to <code>required=false</code>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method argument</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerWebExchange</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the full <code>ServerWebExchange</code>&#8201;&#8212;&#8201;container for the HTTP request and response,
  request and session attributes, <code>checkNotModified</code> methods, and others.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerHttpRequest</code>, <code>ServerHttpResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the HTTP request or response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the session. This does not force the start of a new session unless attributes
  are added. Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The currently authenticated user&#8201;&#8212;&#8201;possibly a specific <code>Principal</code> implementation class if known.
  Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.http.HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The HTTP method of the request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The current request locale, determined by the most specific <code>LocaleResolver</code> available&#8201;&#8212;&#8201;in
  effect, the configured <code>LocaleResolver</code>/<code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to URI template variables. See <a href="#webflux-ann-requestmapping-uri-templates">URI Patterns</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to name-value pairs in URI path segments. See <a href="#webflux-ann-matrix-variables">Matrix Variables</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to Servlet request parameters. Parameter values are converted to the declared
  method argument type. See <a href="#webflux-ann-requestparam"><code>@RequestParam</code></a>.
</p><p class="tableblock">  Note that use of <code>@RequestParam</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
  See &#8220;Any other argument&#8221; later in this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers. Header values are converted to the declared method argument
  type. See <a href="#webflux-ann-requestheader"><code>@RequestHeader</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CookieValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to cookies. Cookie values are converted to the declared method argument type.
  See <a href="#webflux-ann-cookievalue"><code>@CookieValue</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the HTTP request body. Body content is converted to the declared method
  argument type by using <code>HttpMessageReader</code> instances. Supports reactive types.
  See <a href="#webflux-ann-requestbody"><code>@RequestBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers and body. The body is converted with <code>HttpMessageReader</code> instances.
  Supports reactive types. See <a href="#webflux-ann-httpentity"><code>HttpEntity</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to a part in  a <code>multipart/form-data</code> request. Supports reactive types.
  See <a href="#webflux-multipart-forms">Multipart Content</a> and <a href="#webflux-multipart">Multipart Data</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, and <code>org.springframework.ui.ModelMap</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the model that is used in HTML controllers and is exposed to templates as
  part of view rendering.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to an existing attribute in the model (instantiated if not present) with
  data binding and validation applied. See <a href="#webflux-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> as well
  as <a href="#webflux-ann-modelattrib-methods"><code>Model</code></a> and <a href="#webflux-ann-initbinder"><code>DataBinder</code></a>.
</p><p class="tableblock">  Note that use of <code>@ModelAttribute</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
  See &#8220;Any other argument&#8221; later in this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code>, <code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to errors from validation and data binding for a command object
  (that is, a <code>@ModelAttribute</code> argument) or errors from the validation of a <code>@RequestBody</code> or
  <code>@RequestPart</code> argument. An <code>Errors</code>, or <code>BindingResult</code> argument must be declared
  immediately after the validated method argument.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For marking form processing complete, which triggers cleanup of session attributes
  declared through a class-level <code>@SessionAttributes</code> annotation.
  See <a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For preparing a URL relative to the current request&#8217;s host, port, scheme, and path.
  See <a href="#webflux-uri-building">URI Links</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to any session attribute&#8201;&#8212;&#8201;in contrast to model attributes stored in the session
  as a result of a class-level <code>@SessionAttributes</code> declaration. See
  <a href="#webflux-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request attributes. See <a href="#webflux-ann-requestattrib"><code>@RequestAttribute</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a method argument is not matched to any of the above, it is, by default, resolved as
  a <code>@RequestParam</code> if it is a simple type, as determined by
  <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>,
  or as a <code>@ModelAttribute</code>, otherwise.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-return-types"><a class="anchor" href="#webflux-ann-return-types"></a>Return Values</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-return-types">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following table shows the supported controller method return values. Note that reactive types
from libraries such as Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a> are
generally supported for all return values.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method return value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value is encoded through <code>HttpMessageWriter</code> instances and written to the response.
  See <a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value specifies the full response, including HTTP headers, and the body is encoded
  through <code>HttpMessageWriter</code> instances and written to the response.
  See <a href="#webflux-ann-responseentity"><code>ResponseEntity</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For returning a response with headers and no body.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A view name to be resolved with <code>ViewResolver</code> instances and used together with the implicit
  model&#8201;&#8212;&#8201;determined through command objects and <code>@ModelAttribute</code> methods. The handler
  method can also programmatically enrich the model by declaring a <code>Model</code> argument
  (described <a href="#webflux-viewresolution-handling">earlier</a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>View</code> instance to use for rendering together with the implicit model&#8201;&#8212;&#8201;determined
  through command objects and <code>@ModelAttribute</code> methods. The handler method can also
  programmatically enrich the model by declaring a <code>Model</code> argument (described <a href="#webflux-viewresolution-handling">earlier</a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attributes to be added to the implicit model, with the view name implicitly determined
  based on the request path.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An attribute to be added to the model, with the view name implicitly determined based
  on the request path.
</p><p class="tableblock">  Note that <code>@ModelAttribute</code> is optional. See &#8220;Any other return value&#8221; later in
  this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Rendering</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An API for model and view rendering scenarios.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A method with a <code>void</code>, possibly asynchronous (for example, <code>Mono&lt;Void&gt;</code>), return type (or a <code>null</code> return
  value) is considered to have fully handled the response if it also has a <code>ServerHttpResponse</code>,
  a <code>ServerWebExchange</code> argument, or an <code>@ResponseStatus</code> annotation. The same is also true
  if the controller has made a positive ETag or <code>lastModified</code> timestamp check.
  // TODO: See <a href="#webflux-caching-etag-lastmodified">Controllers</a> for details.
</p><p class="tableblock">  If none of the above is true, a <code>void</code> return type can also indicate &#8220;no response body&#8221; for
  REST controllers or default view name selection for HTML controllers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;ServerSentEvent&gt;</code>, <code>Observable&lt;ServerSentEvent&gt;</code>, or other reactive type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Emit server-sent events. The <code>ServerSentEvent</code> wrapper can be omitted when only data needs
  to be written (however, <code>text/event-stream</code> must be requested or declared in the mapping
  through the <code>produces</code> attribute).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other return value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a return value is not matched to any of the above, it is, by default, treated as a view
  name, if it is <code>String</code> or <code>void</code> (default view name selection applies), or as a model
  attribute to be added to the model, unless it is a simple type, as determined by
  <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>,
  in which case it remains unresolved.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-typeconversion"><a class="anchor" href="#webflux-ann-typeconversion"></a>Type Conversion</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-typeconversion">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Some annotated controller method arguments that represent String-based request input (for example,
<code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@PathVariable</code>, <code>@MatrixVariable</code>, and <code>@CookieValue</code>)
can require type conversion if the argument is declared as something other than <code>String</code>.</p>
</div>
<div class="paragraph">
<p>For such cases, type conversion is automatically applied based on the configured converters.
By default, simple types (such as <code>int</code>, <code>long</code>, <code>Date</code>, and others) are supported. Type conversion
can be customized through a <code>WebDataBinder</code> (see <a href="#mvc-ann-initbinder">[mvc-ann-initbinder]</a>) or by registering
<code>Formatters</code> with the <code>FormattingConversionService</code> (see
<a href="core.html#format">Spring Field Formatting</a>).</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-matrix-variables"><a class="anchor" href="#webflux-ann-matrix-variables"></a>Matrix Variables</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-matrix-variables">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a> discusses name-value pairs in
path segments. In Spring WebFlux, we refer to those as &#8220;matrix variables&#8221; based on an
<a href="http://www.w3.org/DesignIssues/MatrixURIs.html">&#8220;old post&#8221;</a> by Tim Berners-Lee, but they
can be also be referred to as URI path parameters.</p>
</div>
<div class="paragraph">
<p>Matrix variables can appear in any path segment, with each variable separated by a semicolon and
multiple values separated by commas&#8201;&#8212;&#8201;for example, <code>"/cars;color=red,green;year=2012"</code>. Multiple
values can also be specified through repeated variable names&#8201;&#8212;&#8201;for example,
<code>"color=red;color=green;color=blue"</code>.</p>
</div>
<div class="paragraph">
<p>Unlike Spring MVC, in WebFlux, the presence or absence of matrix variables in a URL does
not affect request mappings. In other words, you are not required to use a URI variable
to mask variable content. That said, if you want to access matrix variables from a
controller method, you need to add a URI variable to the path segment where matrix
variables are expected. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET /pets/42;q=11;r=22</span>

<span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{petId}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> findPet(<span class="annotation">@PathVariable</span> <span class="predefined-type">String</span> petId, <span class="annotation">@MatrixVariable</span> <span class="type">int</span> q) {

    <span class="comment">// petId == 42</span>
    <span class="comment">// q == 11</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given that all path segments can contain matrix variables, you may sometimes need to
disambiguate which path variable the matrix variable is expected to be in,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET /owners/42;q=11/pets/21;q=22</span>

<span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}/pets/{petId}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> findPet(
        <span class="annotation">@MatrixVariable</span>(name=<span class="string"><span class="delimiter">&quot;</span><span class="content">q</span><span class="delimiter">&quot;</span></span>, pathVar=<span class="string"><span class="delimiter">&quot;</span><span class="content">ownerId</span><span class="delimiter">&quot;</span></span>) <span class="type">int</span> q1,
        <span class="annotation">@MatrixVariable</span>(name=<span class="string"><span class="delimiter">&quot;</span><span class="content">q</span><span class="delimiter">&quot;</span></span>, pathVar=<span class="string"><span class="delimiter">&quot;</span><span class="content">petId</span><span class="delimiter">&quot;</span></span>) <span class="type">int</span> q2) {

    <span class="comment">// q1 == 11</span>
    <span class="comment">// q2 == 22</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can define a matrix variable may be defined as optional and specify a default value
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET /pets/42</span>

<span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{petId}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> findPet(<span class="annotation">@MatrixVariable</span>(required=<span class="predefined-constant">false</span>, defaultValue=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>) <span class="type">int</span> q) {

    <span class="comment">// q == 1</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To get all matrix variables, use a <code>MultiValueMap</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</span>

<span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}/pets/{petId}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> findPet(
        <span class="annotation">@MatrixVariable</span> MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; matrixVars,
        <span class="annotation">@MatrixVariable</span>(pathVar=<span class="string"><span class="delimiter">&quot;</span><span class="content">petId</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">) MultiValueMap&lt;String, String&gt; petMatrixVars) {

    // matrixVars: [</span><span class="delimiter">&quot;</span></span>q<span class="string"><span class="delimiter">&quot;</span><span class="content"> : [11,22], </span><span class="delimiter">&quot;</span></span>r<span class="string"><span class="delimiter">&quot;</span><span class="content"> : 12, </span><span class="delimiter">&quot;</span></span>s<span class="string"><span class="delimiter">&quot;</span><span class="content"> : 23]
    // petMatrixVars: [</span><span class="delimiter">&quot;</span></span>q<span class="string"><span class="delimiter">&quot;</span><span class="content"> : 22, </span><span class="delimiter">&quot;</span></span>s<span class="string"><span class="delimiter">&quot;</span><span class="content"> : 23]
}</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestparam"><a class="anchor" href="#webflux-ann-requestparam"></a><code>@RequestParam</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestparam">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestParam</code> annotation to bind query parameters to a method argument in a
controller. The following code snippet shows the usage:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/pets</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">EditPetForm</span> {

    <span class="comment">// ...</span>

    <span class="annotation">@GetMapping</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> setupForm(<span class="annotation">@RequestParam</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">petId</span><span class="delimiter">&quot;</span></span>) <span class="type">int</span> petId, Model model) { <i class="conum" data-value="1"></i><b>(1)</b>
        Pet pet = <span class="local-variable">this</span>.clinic.loadPet(petId);
        model.addAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">pet</span><span class="delimiter">&quot;</span></span>, pet);
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">petForm</span><span class="delimiter">&quot;</span></span>;
    }

    <span class="comment">// ...</span>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestParam</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Servlet API &#8220;request parameter&#8221; concept conflates query parameters, form
data, and multiparts into one. However, in WebFlux, each is accessed individually through
<code>ServerWebExchange</code>. While <code>@RequestParam</code> binds to query parameters only, you can use
data binding to apply query parameters, form data, and multiparts to a
<a href="#webflux-ann-modelattrib-method-args">command object</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Method parameters that use the <code>@RequestParam</code> annotation are required by default, but
you can specify that a method parameter is optional by setting the required flag of a <code>@RequestParam</code>
to <code>false</code> or by declaring the argument with a <code>java.util.Optional</code>
wrapper.</p>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
<div class="paragraph">
<p>When a <code>@RequestParam</code> annotation is declared on a <code>Map&lt;String, String&gt;</code> or
<code>MultiValueMap&lt;String, String&gt;</code> argument, the map is populated with all query parameters.</p>
</div>
<div class="paragraph">
<p>Note that use of <code>@RequestParam</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes. By
default, any argument that is a simple value type (as determined by
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>)
and is not resolved by any other argument resolver is treated as if it were annotated
with <code>@RequestParam</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestheader"><a class="anchor" href="#webflux-ann-requestheader"></a><code>@RequestHeader</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestheader">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestHeader</code> annotation to bind a request header to a method argument in a
controller.</p>
</div>
<div class="paragraph">
<p>The following example shows a request with headers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example gets the value of the <code>Accept-Encoding</code> and <code>Keep-Alive</code> headers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/demo</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle(
        <span class="annotation">@RequestHeader</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Accept-Encoding</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> encoding, <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="annotation">@RequestHeader</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Keep-Alive</span><span class="delimiter">&quot;</span></span>) <span class="type">long</span> keepAlive) { <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="comment">//...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the value of the <code>Accept-Encoging</code> header.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get the value of the <code>Keep-Alive</code> header.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
<div class="paragraph">
<p>When a <code>@RequestHeader</code> annotation is used on a <code>Map&lt;String, String&gt;</code>,
<code>MultiValueMap&lt;String, String&gt;</code>, or <code>HttpHeaders</code> argument, the map is populated
with all header values.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Built-in support is available for converting a comma-separated string into an
array or collection of strings or other types known to the type conversion system. For
example, a method parameter annotated with <code>@RequestHeader("Accept")</code> may be of type
<code>String</code> but also of <code>String[]</code> or <code>List&lt;String&gt;</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-cookievalue"><a class="anchor" href="#webflux-ann-cookievalue"></a><code>@CookieValue</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-cookievalue">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@CookieValue</code> annotation to bind the value of an HTTP cookie to a method argument
in a controller.</p>
</div>
<div class="paragraph">
<p>The following example shows a request with a cookie:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following code sample demonstrates how to get the cookie value:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/demo</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle(<span class="annotation">@CookieValue</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">JSESSIONID</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> cookie) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="comment">//...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the cookie value.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-modelattrib-method-args"><a class="anchor" href="#webflux-ann-modelattrib-method-args"></a><code>@ModelAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-modelattrib-method-args">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ModelAttribute</code> annotation on a method argument to access an attribute from the
model or have it instantiated if not present. The model attribute is also overlain with
the values of query parameters and form fields whose names match to field names. This is
referred to as data binding, and it saves you from having to deal with parsing and
converting individual query parameters and form fields. The following example binds an instance of <code>Pet</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}/pets/{petId}/edit</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> processSubmit(<span class="annotation">@ModelAttribute</span> Pet pet) { } <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bind an instance of <code>Pet</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>Pet</code> instance in the preceding example is resolved as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From the model if already added through <a href="#webflux-ann-modelattrib-methods"><code>Model</code></a>.</p>
</li>
<li>
<p>From the HTTP session through <a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
</li>
<li>
<p>From the invocation of a default constructor.</p>
</li>
<li>
<p>From the invocation of a &#8220;primary constructor&#8221; with arguments that match query
parameters or form fields. Argument names are determined through JavaBeans
<code>@ConstructorProperties</code> or through runtime-retained parameter names in the bytecode.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After the model attribute instance is obtained, data binding is applied. The
<code>WebExchangeDataBinder</code> class matches names of query parameters and form fields to field
names on the target <code>Object</code>. Matching fields are populated after type conversion is applied
where necessary. For more on data binding (and validation), see
<a href="core.html#validation">Validation</a>. For more on customizing data binding, see
<a href="#webflux-ann-initbinder"><code>DataBinder</code></a>.</p>
</div>
<div class="paragraph">
<p>Data binding can result in errors. By default, a <code>WebExchangeBindException</code> is raised, but,
to check for such errors in the controller method, you can add a <code>BindingResult</code> argument
immediately next to the <code>@ModelAttribute</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}/pets/{petId}/edit</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> processSubmit(<span class="annotation">@ModelAttribute</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">pet</span><span class="delimiter">&quot;</span></span>) Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">if</span> (result.hasErrors()) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">petForm</span><span class="delimiter">&quot;</span></span>;
    }
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding a <code>BindingResult</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You can automatically apply validation after data binding by adding the
<code>javax.validation.Valid</code> annotation or Spring&#8217;s <code>@Validated</code> annotation (see also
<a href="core.html#validation-beanvalidation">Bean validation</a> and
<a href="core.html#validation">Spring validation</a>). The following example uses the <code>@Valid</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}/pets/{petId}/edit</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> processSubmit(<strong><span class="annotation">@Valid</span> <span class="annotation">@ModelAttribute</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">pet</span><span class="delimiter">&quot;</span></span>) Pet pet</strong>, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">if</span> (result.hasErrors()) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">petForm</span><span class="delimiter">&quot;</span></span>;
    }
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@Valid</code> on a model attribute argument.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring WebFlux, unlike Spring MVC, supports reactive types in the model&#8201;&#8212;&#8201;for example,
<code>Mono&lt;Account&gt;</code> or <code>io.reactivex.Single&lt;Account&gt;</code>. You can declare a <code>@ModelAttribute</code> argument
with or without a reactive type wrapper, and it will be resolved accordingly,
to the actual value if necessary. However, note that, to use a <code>BindingResult</code>
argument, you must declare the <code>@ModelAttribute</code> argument before it without a reactive
type wrapper, as shown earlier. Alternatively, you can handle any errors through the
reactive type, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/owners/{ownerId}/pets/{petId}/edit</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> Mono&lt;<span class="predefined-type">String</span>&gt; processSubmit(<span class="annotation">@Valid</span> <span class="annotation">@ModelAttribute</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">pet</span><span class="delimiter">&quot;</span></span>) Mono&lt;Pet&gt; petMono) {
    <span class="keyword">return</span> petMono
        .flatMap(pet -&gt; {
            <span class="comment">// ...</span>
        })
        .onErrorResume(ex -&gt; {
            <span class="comment">// ...</span>
        });
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that use of <code>@ModelAttribute</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
By default, any argument that is not a simple value type( as determined by
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>)
and is not resolved by any other argument resolver is treated as if it were annotated
with <code>@ModelAttribute</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-sessionattributes"><a class="anchor" href="#webflux-ann-sessionattributes"></a><code>@SessionAttributes</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-sessionattributes">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@SessionAttributes</code> is used to store model attributes in the <code>WebSession</code> between
requests. It is a type-level annotation that declares session attributes used by a
specific controller. This typically lists the names of model attributes or types of
model attributes that should be transparently stored in the session for subsequent
requests to access.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="annotation">@SessionAttributes</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">pet</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">public</span> <span class="type">class</span> <span class="class">EditPetForm</span> {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@SessionAttributes</code> annotation.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>On the first request, when a model attribute with the name, <code>pet</code>, is added to the model,
it is automatically promoted to and saved in the <code>WebSession</code>. It remains there until
another controller method uses a <code>SessionStatus</code> method argument to clear the storage,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="annotation">@SessionAttributes</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">pet</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">public</span> <span class="type">class</span> <span class="class">EditPetForm</span> {

    <span class="comment">// ...</span>

    <span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/pets/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">String</span> handle(Pet pet, BindingResult errors, SessionStatus status) { <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="keyword">if</span> (errors.hasErrors) {
            <span class="comment">// ...</span>
        }
            status.setComplete();
            <span class="comment">// ...</span>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@SessionAttributes</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using a <code>SessionStatus</code> variable.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-sessionattribute"><a class="anchor" href="#webflux-ann-sessionattribute"></a><code>@SessionAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-sessionattribute">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>If you need access to pre-existing session attributes that are managed globally
(that is, outside the controller&#8201;&#8212;&#8201;for example, by a filter) and may or may not be present,
you can use the <code>@SessionAttribute</code> annotation on a method parameter, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> handle(<span class="annotation">@SessionAttribute</span> User user) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@SessionAttribute</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>For use cases that require adding or removing session attributes, consider injecting
<code>WebSession</code> into the controller method.</p>
</div>
<div class="paragraph">
<p>For temporary storage of model attributes in the session as part of a controller
workflow, consider using <code>SessionAttributes</code>, as described in
<a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestattrib"><a class="anchor" href="#webflux-ann-requestattrib"></a><code>@RequestAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestattrib">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Similarly to <code>@SessionAttribute</code>, you can use the <code>@RequestAttribute</code> annotation to
access pre-existing request attributes created earlier (for example, by a <code>WebFilter</code>),
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> handle(<span class="annotation">@RequestAttribute</span> Client client) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestAttribute</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multipart-forms"><a class="anchor" href="#webflux-multipart-forms"></a>Multipart Content</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multipart-forms">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>As explained in <a href="#webflux-multipart">Multipart Data</a>, <code>ServerWebExchange</code> provides access to multipart
content. The best way to handle a file upload form (for example, from a browser) in a controller
is through data binding to a <a href="#webflux-ann-modelattrib-method-args">command object</a>,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MyForm</span> {

    <span class="directive">private</span> <span class="predefined-type">String</span> name;

    <span class="directive">private</span> MultipartFile file;

    <span class="comment">// ...</span>

}

<span class="annotation">@Controller</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FileUploadController</span> {

    <span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/form</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">String</span> handleFormUpload(MyForm form, BindingResult errors) {
        <span class="comment">// ...</span>
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also submit multipart requests from non-browser clients in a RESTful service
scenario. The following example uses a file along with JSON:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="literalblock">
<div class="content">
<pre>POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
    "name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can access individual parts with <code>@RequestPart</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> handle(<span class="annotation">@RequestPart</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">meta-data</span><span class="delimiter">&quot;</span></span>) Part metadata, <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="annotation">@RequestPart</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">file-data</span><span class="delimiter">&quot;</span></span>) FilePart file) { <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestPart</code> to get the metadata.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using <code>@RequestPart</code> to get the file.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>To deserialize the raw part content (for example, to JSON&#8201;&#8212;&#8201;similar to <code>@RequestBody</code>),
you can declare a concrete target <code>Object</code>, instead of <code>Part</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> handle(<span class="annotation">@RequestPart</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">meta-data</span><span class="delimiter">&quot;</span></span>) MetaData metadata) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestPart</code> to get the metadata.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use <code>@RequestPart</code> combination with <code>javax.validation.Valid</code> or Spring&#8217;s
<code>@Validated</code> annotation, which causes Standard Bean Validation to be applied.
By default, validation errors cause a <code>WebExchangeBindException</code>, which is turned
into a 400 (<code>BAD_REQUEST</code>) response. Alternatively, you can handle validation errors locally
within the controller through an <code>Errors</code> or <code>BindingResult</code> argument, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> handle(<span class="annotation">@Valid</span> <span class="annotation">@RequestPart</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">meta-data</span><span class="delimiter">&quot;</span></span>) MetaData metadata, <i class="conum" data-value="1"></i><b>(1)</b>
        BindingResult result) { <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>@Valid</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using a <code>BindingResult</code> argument.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>To access all multipart data as a <code>MultiValueMap</code>, you can use <code>@RequestBody</code>,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> handle(<span class="annotation">@RequestBody</span> Mono&lt;MultiValueMap&lt;<span class="predefined-type">String</span>, Part&gt;&gt; parts) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestBody</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>To access multipart data sequentially, in streaming fashion, you can use <code>@RequestBody</code> with
<code>Flux&lt;Part&gt;</code> instead, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> handle(<span class="annotation">@RequestBody</span> Flux&lt;Part&gt; parts) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestBody</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestbody"><a class="anchor" href="#webflux-ann-requestbody"></a><code>@RequestBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestbody">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestBody</code> annotation to have the request body read and deserialized into an
<code>Object</code> through an <a href="#webflux-codecs">HttpMessageReader</a>.
The following example uses a <code>@RequestBody</code> argument:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/accounts</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle(<span class="annotation">@RequestBody</span> Account account) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Unlike Spring MVC, in WebFlux, the <code>@RequestBody</code> method argument supports reactive types
and fully non-blocking reading and (client-to-server) streaming. The following example
uses a <code>Mono</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/accounts</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle(<span class="annotation">@RequestBody</span> Mono&lt;Account&gt; account) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use the <a href="#webflux-config-message-codecs">HTTP message codecs</a> option of the <a href="#webflux-config">WebFlux Config</a> to
configure or customize message readers.</p>
</div>
<div class="paragraph">
<p>You can use <code>@RequestBody</code> in combination with <code>javax.validation.Valid</code> or Spring&#8217;s
<code>@Validated</code> annotation, which causes Standard Bean Validation to be applied.
By default, validation errors cause a <code>WebExchangeBindException</code>, which is turned
into a 400 (<code>BAD_REQUEST</code>) response. Alternatively, you can handle validation errors locally
within the controller through an <code>Errors</code> or a <code>BindingResult</code> argument. The following
example uses a <code>BindingResult</code> argument`:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/accounts</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle(<span class="annotation">@Valid</span> <span class="annotation">@RequestBody</span> Account account, BindingResult result) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-httpentity"><a class="anchor" href="#webflux-ann-httpentity"></a><code>HttpEntity</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-httpentity">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>HttpEntity</code> is more or less identical to using <a href="#webflux-ann-requestbody"><code>@RequestBody</code></a> but is based on a
container object that exposes request headers and the body. The following example uses an
<code>HttpEntity</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/accounts</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> handle(HttpEntity&lt;Account&gt; entity) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-responsebody"><a class="anchor" href="#webflux-ann-responsebody"></a><code>@ResponseBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-responsebody">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ResponseBody</code> annotation on a method to have the return serialized to the
response body through an <a href="#webflux-codecs">HttpMessageWriter</a>. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/accounts/{id}</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@ResponseBody</span>
<span class="directive">public</span> Account handle() {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code> is also supported at the class level, in which case it is inherited by
all controller methods. This is the effect of <code>@RestController</code>, which is nothing more
than a meta-annotation marked with <code>@Controller</code> and <code>@ResponseBody</code>.</p>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code> supports reactive types, which means you can return Reactor or RxJava
types and have the asynchronous values they produce rendered to the response.
For additional details, see <a href="#webflux-codecs-streaming">Streaming</a> and
<a href="#webflux-codecs-jackson">JSON rendering</a>.</p>
</div>
<div class="paragraph">
<p>You can combine <code>@ResponseBody</code> methods with JSON serialization views.
See <a href="#webflux-ann-jackson">Jackson JSON</a> for details.</p>
</div>
<div class="paragraph">
<p>You can use the <a href="#webflux-config-message-codecs">HTTP message codecs</a> option of the <a href="#webflux-config">WebFlux Config</a> to
configure or customize message writing.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-responseentity"><a class="anchor" href="#webflux-ann-responseentity"></a><code>ResponseEntity</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-responseentity">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ResponseEntity</code> is like <a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a> but with status and headers. For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/something</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> ResponseEntity&lt;<span class="predefined-type">String</span>&gt; handle() {
    <span class="predefined-type">String</span> body = ... ;
    <span class="predefined-type">String</span> etag = ... ;
    <span class="keyword">return</span> ResponseEntity.ok().eTag(etag).build(body);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>WebFlux supports using a single value <a href="#webflux-reactive-libraries">reactive type</a> to
produce the <code>ResponseEntity</code> asynchronously, and/or single and multi-value reactive types
for the body.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-jackson"><a class="anchor" href="#webflux-ann-jackson"></a>Jackson JSON</h5>
<div class="paragraph">
<p>Spring offers support for the Jackson JSON library.</p>
</div>
<div class="sect5">
<h6 id="webflux-ann-jsonview"><a class="anchor" href="#webflux-ann-jsonview"></a>Jackson Serialization Views</h6>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-jackson">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux provides built-in support for
<a href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson&#8217;s Serialization Views</a>,
which allows rendering only a subset of all fields in an <code>Object</code>. To use it with
<code>@ResponseBody</code> or <code>ResponseEntity</code> controller methods, you can use Jackson&#8217;s
<code>@JsonView</code> annotation to activate a serialization view class, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">UserController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/user</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@JsonView</span>(User.WithoutPasswordView.class)
    <span class="directive">public</span> User getUser() {
        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string"><span class="delimiter">&quot;</span><span class="content">eric</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">7!jd#h23</span><span class="delimiter">&quot;</span></span>);
    }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">User</span> {

    <span class="directive">public</span> <span class="type">interface</span> <span class="class">WithoutPasswordView</span> {};
    <span class="directive">public</span> <span class="type">interface</span> <span class="class">WithPasswordView</span> <span class="directive">extends</span> WithoutPasswordView {};

    <span class="directive">private</span> <span class="predefined-type">String</span> username;
    <span class="directive">private</span> <span class="predefined-type">String</span> password;

    <span class="directive">public</span> User() {
    }

    <span class="directive">public</span> User(<span class="predefined-type">String</span> username, <span class="predefined-type">String</span> password) {
        <span class="local-variable">this</span>.username = username;
        <span class="local-variable">this</span>.password = password;
    }

    <span class="annotation">@JsonView</span>(WithoutPasswordView.class)
    <span class="directive">public</span> <span class="predefined-type">String</span> getUsername() {
        <span class="keyword">return</span> <span class="local-variable">this</span>.username;
    }

    <span class="annotation">@JsonView</span>(WithPasswordView.class)
    <span class="directive">public</span> <span class="predefined-type">String</span> getPassword() {
        <span class="keyword">return</span> <span class="local-variable">this</span>.password;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@JsonView</code> allows an array of view classes but you can only specify only one per
controller method. Use a composite interface if you need to activate multiple views.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-modelattrib-methods"><a class="anchor" href="#webflux-ann-modelattrib-methods"></a>1.4.4. <code>Model</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-modelattrib-methods">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ModelAttribute</code> annotation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On a <a href="#webflux-ann-modelattrib-method-args">method argument</a> in <code>@RequestMapping</code> methods
to create or access an Object from the model and to bind it to the request through a
<code>WebDataBinder</code>.</p>
</li>
<li>
<p>As a method-level annotation in <code>@Controller</code> or <code>@ControllerAdvice</code> classes, helping
to initialize the model prior to any <code>@RequestMapping</code> method invocation.</p>
</li>
<li>
<p>On a <code>@RequestMapping</code> method to mark its return value as a model attribute.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This section discusses <code>@ModelAttribute</code> methods, or the second item from the preceding list.
A controller can have any number of <code>@ModelAttribute</code> methods. All such methods are
invoked before <code>@RequestMapping</code> methods in the same controller. A <code>@ModelAttribute</code>
method can also be shared across controllers through <code>@ControllerAdvice</code>. See the section on
<a href="#webflux-ann-controller-advice">Controller Advice</a> for more details.</p>
</div>
<div class="paragraph">
<p><code>@ModelAttribute</code> methods have flexible method signatures. They support many of the same
arguments as <code>@RequestMapping</code> methods (except for <code>@ModelAttribute</code> itself and anything
related to the request body).</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>@ModelAttribute</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span>
<span class="directive">public</span> <span class="type">void</span> populateModel(<span class="annotation">@RequestParam</span> <span class="predefined-type">String</span> number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    <span class="comment">// add more ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example adds one attribute only:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span>
<span class="directive">public</span> Account addAccount(<span class="annotation">@RequestParam</span> <span class="predefined-type">String</span> number) {
    <span class="keyword">return</span> accountRepository.findAccount(number);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When a name is not explicitly specified, a default name is chosen based on the type,
as explained in the javadoc for <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a>.
You can always assign an explicit name by using the overloaded <code>addAttribute</code> method or
through the name attribute on <code>@ModelAttribute</code> (for a return value).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring WebFlux, unlike Spring MVC, explicitly supports reactive types in the model
(for example, <code>Mono&lt;Account&gt;</code> or <code>io.reactivex.Single&lt;Account&gt;</code>). Such asynchronous model
attributes can be transparently resolved (and the model updated) to their actual values
at the time of <code>@RequestMapping</code> invocation, provided a <code>@ModelAttribute</code> argument is
declared without a wrapper, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ModelAttribute</span>
<span class="directive">public</span> <span class="type">void</span> addAccount(<span class="annotation">@RequestParam</span> <span class="predefined-type">String</span> number) {
    Mono&lt;Account&gt; accountMono = accountRepository.findAccount(number);
    model.addAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">account</span><span class="delimiter">&quot;</span></span>, accountMono);
}

<span class="annotation">@PostMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/accounts</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">String</span> handle(<span class="annotation">@ModelAttribute</span> Account account, BindingResult errors) {
    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition, any model attributes that have a reactive type wrapper are resolved to their
actual values (and the model updated) just prior to view rendering.</p>
</div>
<div class="paragraph">
<p>You can also use <code>@ModelAttribute</code> as a method-level annotation on <code>@RequestMapping</code>
methods, in which case the return value of the <code>@RequestMapping</code> method is interpreted as a
model attribute. This is typically not required, as it is the default behavior in HTML
controllers, unless the return value is a <code>String</code> that would otherwise be interpreted
as a view name. <code>@ModelAttribute</code> can also help to customize the model attribute name,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/accounts/{id}</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@ModelAttribute</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">myAccount</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> Account handle() {
    <span class="comment">// ...</span>
    <span class="keyword">return</span> account;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-initbinder"><a class="anchor" href="#webflux-ann-initbinder"></a>1.4.5. <code>DataBinder</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-initbinder">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code> or <code>@ControllerAdvice</code> classes can have <code>@InitBinder</code> methods, to
initialize instances of <code>WebDataBinder</code>. Those, in turn, are used to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bind request parameters (that is, form data or query) to a model object.</p>
</li>
<li>
<p>Convert <code>String</code>-based request values (such as request parameters, path variables,
headers, cookies, and others) to the target type of controller method arguments.</p>
</li>
<li>
<p>Format model object values as <code>String</code> values when rendering HTML forms.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@InitBinder</code> methods can register controller-specific <code>java.bean.PropertyEditor</code> or
Spring <code>Converter</code> and <code>Formatter</code> components. In addition, you can use the
<a href="#webflux-config-conversion">WebFlux Java configuration</a> to register <code>Converter</code> and
<code>Formatter</code> types in a globally shared <code>FormattingConversionService</code>.</p>
</div>
<div class="paragraph">
<p><code>@InitBinder</code> methods support many of the same arguments that <code>@RequestMapping</code> methods
do, except for <code>@ModelAttribute</code> (command object) arguments. Typically, they are declared
with a <code>WebDataBinder</code> argument, for registrations, and a <code>void</code> return value.
The following example uses the <code>@InitBinder</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FormController</span> {

    <span class="annotation">@InitBinder</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">public</span> <span class="type">void</span> initBinder(WebDataBinder binder) {
        <span class="predefined-type">SimpleDateFormat</span> dateFormat = <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">yyyy-MM-dd</span><span class="delimiter">&quot;</span></span>);
        dateFormat.setLenient(<span class="predefined-constant">false</span>);
        binder.registerCustomEditor(<span class="predefined-type">Date</span>.class, <span class="keyword">new</span> CustomDateEditor(dateFormat, <span class="predefined-constant">false</span>));
    }

    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@InitBinder</code> annotation.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, when using a <code>Formatter</code>-based setup through a shared
<code>FormattingConversionService</code>, you could re-use the same approach and register
controller-specific <code>Formatter</code> instances, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FormController</span> {

    <span class="annotation">@InitBinder</span>
    <span class="directive">protected</span> <span class="type">void</span> initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(<span class="keyword">new</span> <span class="predefined-type">DateFormatter</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">yyyy-MM-dd</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding a custom formatter (a <code>DateFormatter</code>, in this case).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller-exceptions"><a class="anchor" href="#webflux-ann-controller-exceptions"></a>1.4.6. Managing Exceptions</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-exceptionhandler">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code> and <a href="#mvc-ann-controller-advice">@ControllerAdvice</a> classes can have
<code>@ExceptionHandler</code> methods to handle exceptions from controller methods. The following
example includes such a handler method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleController</span> {

    <span class="comment">// ...</span>

    <span class="annotation">@ExceptionHandler</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">public</span> ResponseEntity&lt;<span class="predefined-type">String</span>&gt; handle(<span class="exception">IOException</span> ex) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declaring an <code>@ExceptionHandler</code>:</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The exception can match against a top-level exception being propagated (that is, a direct
<code>IOException</code> being thrown) or against the immediate cause within a top-level wrapper exception
(for example, an <code>IOException</code> wrapped inside an <code>IllegalStateException</code>).</p>
</div>
<div class="paragraph">
<p>For matching exception types, preferably declare the target exception as a method argument,
as shown in the preceding example. Alternatively, the annotation declaration can narrow the exception types to
match. We generally recommend being as specific as possible in the argument signature and to
declare your primary root exception mappings on a <code>@ControllerAdvice</code> prioritized with a
corresponding order. See <a href="web.html#mvc-ann-exceptionhandler">the MVC section</a> for details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An <code>@ExceptionHandler</code> method in WebFlux supports the same method arguments and
return values as a <code>@RequestMapping</code> method, with the exception of request body-
and <code>@ModelAttribute</code>-related method arguments.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Support for <code>@ExceptionHandler</code> methods in Spring WebFlux is provided by the
<code>HandlerAdapter</code> for <code>@RequestMapping</code> methods. See <a href="#webflux-dispatcher-handler"><code>DispatcherHandler</code></a>
for more detail.</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-rest-exceptions"><a class="anchor" href="#webflux-ann-rest-exceptions"></a>REST API exceptions</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-rest-exceptions">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>A common requirement for REST services is to include error details in the body of the
response. The Spring Framework does not automatically do so, because the representation
of error details in the response body is application-specific. However, a
<code>@RestController</code> can use <code>@ExceptionHandler</code> methods with a <code>ResponseEntity</code> return
value to set the status and the body of the response. Such methods can also be declared
in <code>@ControllerAdvice</code> classes to apply them globally.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that Spring WebFlux does not have an equivalent for the Spring MVC
<code>ResponseEntityExceptionHandler</code>, because WebFlux raises only <code>ResponseStatusException</code>
(or subclasses thereof), and those do not need to be translated to
an HTTP status code.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller-advice"><a class="anchor" href="#webflux-ann-controller-advice"></a>1.4.7. Controller Advice</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-controller-advice">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Typically, the <code>@ExceptionHandler</code>, <code>@InitBinder</code>, and <code>@ModelAttribute</code> methods apply within
the <code>@Controller</code> class (or class hierarchy) in which they are declared. If you want such
methods to apply more globally (across controllers), you can declare them in a class
marked with <code>@ControllerAdvice</code> or <code>@RestControllerAdvice</code>.</p>
</div>
<div class="paragraph">
<p><code>@ControllerAdvice</code> is marked with <code>@Component</code>, which means that such classes can be registered
as Spring beans through <a href="core.html#beans-java-instantiating-container-scan">component scanning</a>.
<code>@RestControllerAdvice</code> is also a meta-annotation marked with both <code>@ControllerAdvice</code> and
<code>@ResponseBody</code>, which essentially means <code>@ExceptionHandler</code> methods are rendered to the
response body through message conversion (versus view resolution or template rendering).</p>
</div>
<div class="paragraph">
<p>On startup, the infrastructure classes for <code>@RequestMapping</code> and <code>@ExceptionHandler</code> methods
detect Spring beans of type <code>@ControllerAdvice</code> and apply their methods at runtime.
Global <code>@ExceptionHandler</code> methods (from a <code>@ControllerAdvice</code>) are applied <strong>after</strong> local
ones (from the <code>@Controller</code>). By contrast, global <code>@ModelAttribute</code> and <code>@InitBinder</code>
methods are applied <strong>before</strong> local ones.</p>
</div>
<div class="paragraph">
<p>By default <code>@ControllerAdvice</code> methods apply to every request (that is, all controllers), but
you can narrow that down to a subset of controllers through attributes on the annotation,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Target all Controllers annotated with @RestController</span>
<span class="annotation">@ControllerAdvice</span>(annotations = RestController.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice1</span> {}

<span class="comment">// Target all Controllers within specific packages</span>
<span class="annotation">@ControllerAdvice</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.controllers</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice2</span> {}

<span class="comment">// Target all Controllers assignable to specific classes</span>
<span class="annotation">@ControllerAdvice</span>(assignableTypes = {ControllerInterface.class, AbstractController.class})
<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleAdvice3</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding selectors are evaluated at runtime and may negatively impact
performance if you use them extensively. See the
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a>
javadoc for more details.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-fn"><a class="anchor" href="#webflux-fn"></a>1.5. Functional Endpoints</h3>
<div class="paragraph">
<p>Spring WebFlux includes WebFlux.fn, a lightweight functional programming model in which functions
are used to route and handle requests and contracts are designed for immutability.
It is an alternative to the annotation-based programming model but otherwise runs on
the same <a href="#webflux-reactive-spring-web">Reactive Core</a> foundation.</p>
</div>
<div class="sect3">
<h4 id="webflux-fn-overview"><a class="anchor" href="#webflux-fn-overview"></a>1.5.1. Overview</h4>
<div class="paragraph">
<p>In WebFlux.fn, an HTTP request is handled with a <code>HandlerFunction</code>: a function that takes
<code>ServerRequest</code> and returns a delayed <code>ServerResponse</code> (i.e. <code>Mono&lt;ServerResponse&gt;</code>).
Both the request as the response object have immutable contracts that offer JDK 8-friendly
access to the HTTP request and response.
<code>HandlerFunction</code> is the equivalent of the body of a <code>@RequestMapping</code> method in the
annotation-based programming model.</p>
</div>
<div class="paragraph">
<p>Incoming requests are routed to a handler function with a <code>RouterFunction</code>: a function that
takes <code>ServerRequest</code> and returns a delayed <code>HandlerFunction</code> (i.e. <code>Mono&lt;HandlerFunction&gt;</code>).
When the router function matches, a handler function is returned; otherwise an empty Mono.
<code>RouterFunction</code> is the equivalent of a <code>@RequestMapping</code> annotation, but with the major
difference that router functions provide not just data, but also behavior.</p>
</div>
<div class="paragraph">
<p><code>RouterFunctions.route()</code> provides a router builder that facilitates the creation of routers,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http.MediaType.APPLICATION_JSON</span>;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.server.RequestPredicates</span>.*;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.server.RouterFunctions.route</span>;

PersonRepository repository = ...
PersonHandler handler = <span class="keyword">new</span> PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person/{id}</span><span class="delimiter">&quot;</span></span>, accept(APPLICATION_JSON), handler::getPerson)
    .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, accept(APPLICATION_JSON), handler::listPeople)
    .POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, handler::createPerson)
    .build();


<span class="directive">public</span> <span class="type">class</span> <span class="class">PersonHandler</span> {

    <span class="comment">// ...</span>

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) {
        <span class="comment">// ...</span>
    }

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) {
        <span class="comment">// ...</span>
    }

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>One way to run a <code>RouterFunction</code> is to turn it into an <code>HttpHandler</code> and install it
through one of the built-in <a href="#webflux-httphandler">server adapters</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most applications can run through the WebFlux Java configuration, see <a href="#webflux-fn-running">Running a Server</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-functions"><a class="anchor" href="#webflux-fn-handler-functions"></a>1.5.2. HandlerFunction</h4>
<div class="paragraph">
<p><code>ServerRequest</code> and <code>ServerResponse</code> are immutable interfaces that offer JDK 8-friendly
access to the HTTP request and response.
Both request and response provide <a href="http://www.reactive-streams.org">Reactive Streams</a> back pressure
against the body streams.
The request body is represented with a Reactor <code>Flux</code> or <code>Mono</code>.
The response body is represented with any Reactive Streams <code>Publisher</code>, including <code>Flux</code> and <code>Mono</code>.
For more on that, see <a href="#webflux-reactive-libraries">Reactive Libraries</a>.</p>
</div>
<div class="sect4">
<h5 id="webflux-fn-request"><a class="anchor" href="#webflux-fn-request"></a><code>ServerRequest</code></h5>
<div class="paragraph">
<p><code>ServerRequest</code> provides access to the HTTP method, URI, headers, and query parameters,
while access to the body is provided through the <code>body</code> methods.</p>
</div>
<div class="paragraph">
<p>The following example extracts the request body to a <code>Mono&lt;String&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono&lt;<span class="predefined-type">String</span>&gt; string = request.bodyToMono(<span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example extracts the body to a <code>Flux&lt;Person&gt;</code>, where <code>Person</code> objects are decoded from some
serialized form, such as JSON or XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux&lt;Person&gt; people = request.bodyToFlux(Person.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding examples are shortcuts that use the more general <code>ServerRequest.body(BodyExtractor)</code>,
which accepts the <code>BodyExtractor</code> functional strategy interface. The utility class
<code>BodyExtractors</code> provides access to a number of instances. For example, the preceding examples can
also be written as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono&lt;<span class="predefined-type">String</span>&gt; string = request.body(BodyExtractors.toMono(<span class="predefined-type">String</span>.class));
Flux&lt;Person&gt; people = request.body(BodyExtractors.toFlux(Person.class));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to access form data:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono&lt;MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; map = request.body(BodyExtractors.toFormData());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to access multipart data as a map:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono&lt;MultiValueMap&lt;<span class="predefined-type">String</span>, Part&gt; map = request.body(BodyExtractors.toMultipartData());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to access multiparts, one at a time, in streaming fashion:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Flux&lt;Part&gt; parts = request.body(BodyExtractos.toParts());</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-response"><a class="anchor" href="#webflux-fn-response"></a><code>ServerResponse</code></h5>
<div class="paragraph">
<p><code>ServerResponse</code> provides access to the HTTP response and, since it is immutable, you can use
a <code>build</code> method to create it. You can use the builder to set the response status, to add response
headers, or to provide a body. The following example creates a 200 (OK) response with JSON
content:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Mono&lt;Person&gt; person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person, Person.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to build a 201 (CREATED) response with a <code>Location</code> header and no body:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> location = ...
ServerResponse.created(location).build();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-handler-classes"><a class="anchor" href="#webflux-fn-handler-classes"></a>Handler Classes</h5>
<div class="paragraph">
<p>We can write a handler function as a lambda, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HandlerFunction&lt;ServerResponse&gt; helloWorld =
  request -&gt; ServerResponse.ok().body(fromObject(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That is convenient, but in an application we need multiple functions, and multiple inline
lambda&#8217;s can get messy.
Therefore, it is useful to group related handler functions together into a handler class, which
has a similar role as  <code>@Controller</code> in an annotation-based application.
For example, the following class exposes a reactive <code>Person</code> repository:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http.MediaType.APPLICATION_JSON</span>;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.ServerResponse.ok</span>;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.BodyInserters.fromObject</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">PersonHandler</span> {

    <span class="directive">private</span> <span class="directive">final</span> PersonRepository repository;

    <span class="directive">public</span> PersonHandler(PersonRepository repository) {
        <span class="local-variable">this</span>.repository = repository;
    }

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) { <i class="conum" data-value="1"></i><b>(1)</b>
        Flux&lt;Person&gt; people = repository.allPeople();
        <span class="keyword">return</span> ok().contentType(APPLICATION_JSON).body(people, Person.class);
    }

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) { <i class="conum" data-value="2"></i><b>(2)</b>
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class);
        <span class="keyword">return</span> ok().build(repository.savePerson(person));
    }

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) { <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="type">int</span> personId = <span class="predefined-type">Integer</span>.valueOf(request.pathVariable(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>));
        <span class="keyword">return</span> repository.getPerson(personId)
            .flatMap(person -&gt; ok().contentType(APPLICATION_JSON).body(fromObject(person)))
            .switchIfEmpty(ServerResponse.notFound().build());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>listPeople</code> is a handler function that returns all <code>Person</code> objects found in the repository as
JSON.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>createPerson</code> is a handler function that stores a new <code>Person</code> contained in the request body.
Note that <code>PersonRepository.savePerson(Person)</code> returns <code>Mono&lt;Void&gt;</code>: an empty <code>Mono</code> that emits
a completion signal when the person has been read from the request and stored. So we use the
<code>build(Publisher&lt;Void&gt;)</code> method to send a response when that completion signal is received (that is,
when the <code>Person</code> has been saved).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>getPerson</code> is a handler function that returns a single person, identified by the <code>id</code> path
variable. We retrieve that <code>Person</code> from the repository and create a JSON response, if it is
found. If it is not found, we use <code>switchIfEmpty(Mono&lt;T&gt;)</code> to return a 404 Not Found response.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-handler-validation"><a class="anchor" href="#webflux-fn-handler-validation"></a>Validation</h5>
<div class="paragraph">
<p>A functional endpoint can use Spring&#8217;s <a href="core.html#validation">validation facilities</a> to
apply validation to the request body. For example, given a custom Spring
<a href="core.html#validation">Validator</a> implementation for a <code>Person</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonHandler</span> {

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Validator</span> validator = <span class="keyword">new</span> PersonValidator(); <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="comment">// ...</span>

    <span class="directive">public</span> Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) {
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class).doOnNext(<span class="local-variable">this</span>::validate); <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="keyword">return</span> ok().build(repository.savePerson(person));
    }

    <span class="directive">private</span> <span class="type">void</span> validate(Person person) {
        Errors errors = <span class="keyword">new</span> BeanPropertyBindingResult(body, <span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>);
        validator.validate(body, errors);
        <span class="keyword">if</span> (errors.hasErrors) {
            <span class="keyword">throw</span> <span class="keyword">new</span> ServerWebInputException(errors.toString()); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create <code>Validator</code> instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Apply validation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Raise exception for a 400 response.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Handlers can also use the standard bean validation API (JSR-303) by creating and injecting
a global <code>Validator</code> instance based on <code>LocalValidatorFactoryBean</code>.
See <a href="core.html#validation-beanvalidation">Spring Validation</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-router-functions"><a class="anchor" href="#webflux-fn-router-functions"></a>1.5.3. <code>RouterFunction</code></h4>
<div class="paragraph">
<p>Router functions are used to route the requests to the corresponding <code>HandlerFunction</code>.
Typically, you do not write router functions yourself, but rather use a method on the
<code>RouterFunctions</code> utility class to create one.
<code>RouterFunctions.route()</code> (no parameters) provides you with a fluent builder for creating a router
function, whereas <code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code> offers a direct way
to create a router.</p>
</div>
<div class="paragraph">
<p>Generally, it is recommended to use the <code>route()</code> builder, as it provides
convenient short-cuts for typical mapping scenarios without requiring hard-to-discover
static imports.
For instance, the router function builder offers the method <code>GET(String, HandlerFunction)</code> to create a mapping for GET requests; and <code>POST(String, HandlerFunction)</code> for POSTs.</p>
</div>
<div class="paragraph">
<p>Besides HTTP method-based mapping, the route builder offers a way to introduce additional
predicates when mapping to requests.
For each HTTP method there is an overloaded variant that takes a <code>RequestPredicate</code> as a
parameter, though which additional constraints can be expressed.</p>
</div>
<div class="sect4">
<h5 id="webflux-fn-predicates"><a class="anchor" href="#webflux-fn-predicates"></a>Predicates</h5>
<div class="paragraph">
<p>You can write your own <code>RequestPredicate</code>, but the <code>RequestPredicates</code> utility class
offers commonly used implementations, based on the request path, HTTP method, content-type,
and so on.
The following example uses a request predicate to create a constraint based on the <code>Accept</code>
header:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route()
    .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/hello-world</span><span class="delimiter">&quot;</span></span>, accept(MediaType.TEXT_PLAIN),
        request -&gt; Response.ok().body(fromObject(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>)));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can compose multiple request predicates together by using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RequestPredicate.and(RequestPredicate)</code>&#8201;&#8212;&#8201;both must match.</p>
</li>
<li>
<p><code>RequestPredicate.or(RequestPredicate)</code>&#8201;&#8212;&#8201;either can match.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Many of the predicates from <code>RequestPredicates</code> are composed.
For example, <code>RequestPredicates.GET(String)</code> is composed from <code>RequestPredicates.method(HttpMethod)</code>
and <code>RequestPredicates.path(String)</code>.
The example shown above also uses two request predicates, as the builder uses
<code>RequestPredicates.GET</code> internally, and composes that with the <code>accept</code> predicate.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-routes"><a class="anchor" href="#webflux-fn-routes"></a>Routes</h5>
<div class="paragraph">
<p>Router functions are evaluated in order: if the first route does not match, the
second is evaluated, and so on.
Therefore, it makes sense to declare more specific routes before general ones.
Note that this behavior is different from the annotation-based programming model, where the
"most specific" controller method is picked automatically.</p>
</div>
<div class="paragraph">
<p>When using the router function builder, all defined routes are composed into one
<code>RouterFunction</code> that is returned from <code>build()</code>.
There are also other ways to compose multiple router functions together:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>add(RouterFunction)</code> on the <code>RouterFunctions.route()</code> builder</p>
</li>
<li>
<p><code>RouterFunction.and(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code>&#8201;&#8212;&#8201;shortcut for
<code>RouterFunction.and()</code> with nested <code>RouterFunctions.route()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows the composition of four routes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.http.MediaType.APPLICATION_JSON</span>;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.server.RequestPredicates</span>.*;

PersonRepository repository = ...
PersonHandler handler = <span class="keyword">new</span> PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; otherRoute = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person/{id}</span><span class="delimiter">&quot;</span></span>, accept(APPLICATION_JSON), handler::getPerson) <i class="conum" data-value="1"></i><b>(1)</b>
    .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, accept(APPLICATION_JSON), handler::listPeople) <i class="conum" data-value="2"></i><b>(2)</b>
    .POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, handler::createPerson) <i class="conum" data-value="3"></i><b>(3)</b>
    .add(otherRoute) <i class="conum" data-value="4"></i><b>(4)</b>
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>GET /person/{id}</code> with an <code>Accept</code> header that matches JSON is routed to
<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>GET /person</code> with an <code>Accept</code> header that matches JSON is routed to
<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>POST /person</code> with no additional predicates is mapped to
<code>PersonHandler.createPerson</code>, and</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>otherRoute</code> is a router function that is created elsewhere, and added to the route built.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nested-routes"><a class="anchor" href="#nested-routes"></a>Nested Routes</h5>
<div class="paragraph">
<p>It is common for a group of router functions to have a shared predicate, for instance a shared
path.
In the example above, the shared predicate would be a path predicate that matches <code>/person</code>,
used by three of the routes.
When using annotations, you would remove this duplication by using a type-level <code>@RequestMapping</code>
 annotation that maps to <code>/person</code>.
In WebFlux.fn, path predicates can be shared through the <code>path</code> method on the router function builder.
For instance, the last few lines of the example above can be improved in the following way by using nested routes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, builder -&gt; builder
        .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>, accept(APPLICATION_JSON), handler::getPerson)
        .GET(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>, accept(APPLICATION_JSON), handler::listPeople)
        .POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, handler::createPerson))
    .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that second parameter of <code>path</code> is a consumer that takes the a router builder.</p>
</div>
<div class="paragraph">
<p>Though path-based nesting is the most common, you can nest on any kind of predicate by using
the <code>nest</code> method on the builder.
The above still contains some duplication in the form of the shared <code>Accept</code>-header predicate.
We can further improve by using the <code>nest</code> method together with <code>accept</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>, handler::getPerson)
            .GET(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>, handler::listPeople))
        .POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, handler::createPerson))
    .build();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-running"><a class="anchor" href="#webflux-fn-running"></a>1.5.4. Running a Server</h4>
<div class="paragraph">
<p>How do you run a router function in an HTTP server? A simple option is to convert a router
function to an <code>HttpHandler</code> by using one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can then use the returned <code>HttpHandler</code> with a number of server adapters by following
<a href="#webflux-httphandler">HttpHandler</a> for server-specific instructions.</p>
</div>
<div class="paragraph">
<p>A more typical option, also used by Spring Boot, is to run with a
<a href="#webflux-dispatcher-handler"><code>DispatcherHandler</code></a>-based setup through the
<a href="#webflux-config">WebFlux Config</a>, which uses Spring configuration to declare the
components required to process requests. The WebFlux Java configuration declares the following
infrastructure components to support functional endpoints:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctionMapping</code>: Detects one or more <code>RouterFunction&lt;?&gt;</code> beans in the Spring
configuration, combines them through <code>RouterFunction.andOther</code>, and routes requests to the
resulting composed <code>RouterFunction</code>.</p>
</li>
<li>
<p><code>HandlerFunctionAdapter</code>: Simple adapter that lets <code>DispatcherHandler</code> invoke
a <code>HandlerFunction</code> that was mapped to a request.</p>
</li>
<li>
<p><code>ServerResponseResultHandler</code>: Handles the result from the invocation of a
<code>HandlerFunction</code> by invoking the <code>writeTo</code> method of the <code>ServerResponse</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The preceding components let functional endpoints fit within the <code>DispatcherHandler</code> request
processing lifecycle and also (potentially) run side by side with annotated controllers, if
any are declared. It is also how functional endpoints are enabled by the Spring Boot WebFlux
starter.</p>
</div>
<div class="paragraph">
<p>The following example shows a WebFlux Java configuration (see
<a href="#webflux-dispatcher-handler">DispatcherHandler</a> for how to run it):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> RouterFunction&lt;?&gt; routerFunctionA() {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> RouterFunction&lt;?&gt; routerFunctionB() {
        <span class="comment">// ...</span>
    }

    <span class="comment">// ...</span>

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        <span class="comment">// configure message conversion...</span>
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addCorsMappings(CorsRegistry registry) {
        <span class="comment">// configure CORS...</span>
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        <span class="comment">// configure view resolution for HTML rendering...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-filter-function"><a class="anchor" href="#webflux-fn-handler-filter-function"></a>1.5.5. Filtering Handler Functions</h4>
<div class="paragraph">
<p>You can filter handler functions by using the <code>before</code>, <code>after</code>, or <code>filter</code> methods on the routing
function builder.
With annotations, you can achieve similar functionality by using <code>@ControllerAdvice</code>, a <code>ServletFilter</code>, or both.
The filter will apply to all routes that are built by the builder.
This means that filters defined in nested routes do not apply to "top-level" routes.
For instance, consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>, handler::getPerson)
            .GET(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>, handler::listPeople)
            .before(request -&gt; ServerRequest.from(request) <i class="conum" data-value="1"></i><b>(1)</b>
                .header(<span class="string"><span class="delimiter">&quot;</span><span class="content">X-RequestHeader</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Value</span><span class="delimiter">&quot;</span></span>)
                .build()))
        .POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, handler::createPerson))
    .after((request, response) -&gt; logResponse(response)) <i class="conum" data-value="2"></i><b>(2)</b>
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>before</code> filter that adds a custom request header is only applied to the two GET routes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>after</code> filter that logs the response is applied to all routes, including the nested ones.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>filter</code> method on the router builder takes a <code>HandlerFilterFunction</code>: a
function that takes a <code>ServerRequest</code> and <code>HandlerFunction</code> and returns a <code>ServerResponse</code>.
The handler function parameter represents the next element in the chain.
This is typically the handler that is routed to, but it can also be another
filter if multiple are applied.</p>
</div>
<div class="paragraph">
<p>Now we can add a simple security filter to our route, assuming that we have a <code>SecurityManager</code> that
can determine whether a particular path is allowed.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">SecurityManager</span> securityManager = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>, handler::getPerson)
            .GET(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>, handler::listPeople))
        .POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">/person</span><span class="delimiter">&quot;</span></span>, handler::createPerson))
    .filter((request, next) -&gt; {
        <span class="keyword">if</span> (securityManager.allowAccessTo(request.path())) {
            <span class="keyword">return</span> next.handle(request);
        }
        <span class="keyword">else</span> {
            <span class="keyword">return</span> ServerResponse.status(UNAUTHORIZED).build();
        }
    })
    .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example demonstrates that invoking the <code>next.handle(ServerRequest)</code> is optional.
We allow only the handler function to be executed when access is allowed.</p>
</div>
<div class="paragraph">
<p>Besides using the <code>filter</code> method on the router function builder, it is possible to apply a
filter to an existing router function via <code>RouterFunction.filter(HandlerFilterFunction)</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
CORS support for functional endpoints is provided through a dedicated <a href="#webflux-cors-webfilter"><code>CorsWebFilter</code></a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-uri-building"><a class="anchor" href="#webflux-uri-building"></a>1.6. URI Links</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-uri-building">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>This section describes various options available in the Spring Framework to prepare URIs.</p>
</div>
<div class="sect3">
<h4 id="web-uricomponents"><a class="anchor" href="#web-uricomponents"></a>1.6.1. UriComponents</h4>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code> helps to build URI&#8217;s from URI templates with variables, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UriComponents uriComponents = UriComponentsBuilder
        .fromUriString(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.com/hotels/{hotel}</span><span class="delimiter">&quot;</span></span>)  <i class="conum" data-value="1"></i><b>(1)</b>
        .queryParam(<span class="string"><span class="delimiter">&quot;</span><span class="content">q</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">{q}</span><span class="delimiter">&quot;</span></span>)  <i class="conum" data-value="2"></i><b>(2)</b>
        .encode() <i class="conum" data-value="3"></i><b>(3)</b>
        .build(); <i class="conum" data-value="4"></i><b>(4)</b>

<span class="predefined-type">URI</span> uri = uriComponents.expand(<span class="string"><span class="delimiter">&quot;</span><span class="content">Westin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>).toUri();  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Static factory method with a URI template.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Add or replace URI components.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Request to have the URI template and URI variables encoded.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Build a <code>UriComponents</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Expand variables and obtain the <code>URI</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example can be consolidated into one chain and shortened with <code>buildAndExpand</code>,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder
        .fromUriString(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.com/hotels/{hotel}</span><span class="delimiter">&quot;</span></span>)
        .queryParam(<span class="string"><span class="delimiter">&quot;</span><span class="content">q</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">{q}</span><span class="delimiter">&quot;</span></span>)
        .encode()
        .buildAndExpand(<span class="string"><span class="delimiter">&quot;</span><span class="content">Westin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>)
        .toUri();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can shorten it further by going directly to a URI (which implies encoding),
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder
        .fromUriString(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.com/hotels/{hotel}</span><span class="delimiter">&quot;</span></span>)
        .queryParam(<span class="string"><span class="delimiter">&quot;</span><span class="content">q</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">{q}</span><span class="delimiter">&quot;</span></span>)
        .build(<span class="string"><span class="delimiter">&quot;</span><span class="content">Westin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You shorter it further still with a full URI template, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder
        .fromUriString(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.com/hotels/{hotel}?q={q}</span><span class="delimiter">&quot;</span></span>)
        .build(<span class="string"><span class="delimiter">&quot;</span><span class="content">Westin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uribuilder"><a class="anchor" href="#web-uribuilder"></a>1.6.2. UriBuilder</h4>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><a href="#web-uricomponents"><code>UriComponentsBuilder</code></a> implements <code>UriBuilder</code>. You can create a <code>UriBuilder</code>, in turn,
with a <code>UriBuilderFactory</code>. Together, <code>UriBuilderFactory</code> and <code>UriBuilder</code>
provide a pluggable mechanism to build URIs from URI templates, based on shared
configuration, such as a base URL, encoding preferences, and other details.</p>
</div>
<div class="paragraph">
<p>You can configure <code>RestTemplate</code> and <code>WebClient</code> with a <code>UriBuilderFactory</code>
to customize the preparation of URIs. <code>DefaultUriBuilderFactory</code> is a default
implementation of <code>UriBuilderFactory</code> that uses <code>UriComponentsBuilder</code> internally and
exposes shared configuration options.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a <code>RestTemplate</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span>

<span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.org</span><span class="delimiter">&quot;</span></span>;
DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);

RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();
restTemplate.setUriTemplateHandler(factory);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example configures a <code>WebClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span>

<span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.org</span><span class="delimiter">&quot;</span></span>;
DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition, you can also use <code>DefaultUriBuilderFactory</code> directly. It is similar to using
<code>UriComponentsBuilder</code> but, instead of static factory methods, it is an actual instance
that holds configuration and preferences, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.com</span><span class="delimiter">&quot;</span></span>;
DefaultUriBuilderFactory uriBuilderFactory = <span class="keyword">new</span> DefaultUriBuilderFactory(baseUrl);

<span class="predefined-type">URI</span> uri = uriBuilderFactory.uriString(<span class="string"><span class="delimiter">&quot;</span><span class="content">/hotels/{hotel}</span><span class="delimiter">&quot;</span></span>)
        .queryParam(<span class="string"><span class="delimiter">&quot;</span><span class="content">q</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">{q}</span><span class="delimiter">&quot;</span></span>)
        .build(<span class="string"><span class="delimiter">&quot;</span><span class="content">Westin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uri-encoding"><a class="anchor" href="#web-uri-encoding"></a>1.6.3. URI Encoding</h4>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code> exposes encoding options at two levels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder#encode()</a>:
Pre-encodes the URI template first and then strictly encodes URI variables when expanded.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents#encode()</a>:
Encodes URI components <em>after</em> URI variables are expanded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both options replace non-ASCII and illegal characters with escaped octets. However, the first option
also replaces characters with reserved meaning that appear in URI variables.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Consider ";", which is legal in a path but has reserved meaning. The first option replaces
";" with "%3B" in URI variables but not in the URI template. By contrast, the second option never
replaces ";", since it is a legal character in a path.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For most cases, the first option is likely to give the expected result, because it treats URI
variables as opaque data to be fully encoded, while option 2 is useful only if
URI variables intentionally contain reserved characters.</p>
</div>
<div class="paragraph">
<p>The following example uses the first option:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/hotel list/{city}</span><span class="delimiter">&quot;</span></span>)
            .queryParam(<span class="string"><span class="delimiter">&quot;</span><span class="content">q</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">{q}</span><span class="delimiter">&quot;</span></span>)
            .encode()
            .buildAndExpand(<span class="string"><span class="delimiter">&quot;</span><span class="content">New York</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">foo+bar</span><span class="delimiter">&quot;</span></span>)
            .toUri();

    <span class="comment">// Result is &quot;/hotel%20list/New%20York?q=foo%2Bbar&quot;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can shorten the preceding example by going directly to the URI (which implies encoding),
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/hotel list/{city}</span><span class="delimiter">&quot;</span></span>)
            .queryParam(<span class="string"><span class="delimiter">&quot;</span><span class="content">q</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">{q}</span><span class="delimiter">&quot;</span></span>)
            .build(<span class="string"><span class="delimiter">&quot;</span><span class="content">New York</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">foo+bar</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can shorten it further still with a full URI template, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = UriComponentsBuilder.fromPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/hotel list/{city}?q={q}</span><span class="delimiter">&quot;</span></span>)
            .build(<span class="string"><span class="delimiter">&quot;</span><span class="content">New York</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">foo+bar</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>WebClient</code> and the <code>RestTemplate</code> expand and encode URI templates internally through
the <code>UriBuilderFactory</code> strategy. Both can be configured with a custom strategy.
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> baseUrl = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.com</span><span class="delimiter">&quot;</span></span>;
DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory(baseUrl)
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

<span class="comment">// Customize the RestTemplate..</span>
RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();
restTemplate.setUriTemplateHandler(factory);

<span class="comment">// Customize the WebClient..</span>
WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultUriBuilderFactory</code> implementation uses <code>UriComponentsBuilder</code> internally to
expand and encode URI templates. As a factory, it provides a single place to configure
the approach to encoding, based on one of the below encoding modes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPLATE_AND_VALUES</code>: Uses <code>UriComponentsBuilder#encode()</code>, corresponding to
the first option in the earlier list, to pre-encode the URI template and strictly encode URI variables when
expanded.</p>
</li>
<li>
<p><code>VALUES_ONLY</code>: Does not encode the URI template and, instead, applies strict encoding
to URI variables through <code>UriUtils#encodeUriUriVariables</code> prior to expanding them into the
template.</p>
</li>
<li>
<p><code>URI_COMPONENTS</code>: Uses <code>UriComponents#encode()</code>, corresponding to the second option in the earlier list, to
encode URI component value <em>after</em> URI variables are expanded.</p>
</li>
<li>
<p><code>NONE</code>: No encoding is applied.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>RestTemplate</code> is set to <code>EncodingMode.URI_COMPONENTS</code> for historic
reasons and for backwards compatibility. The <code>WebClient</code> relies on the default value
in <code>DefaultUriBuilderFactory</code>, which was changed from <code>EncodingMode.URI_COMPONENTS</code> in
5.0.x to <code>EncodingMode.TEMPLATE_AND_VALUES</code> in 5.1.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-cors"><a class="anchor" href="#webflux-cors"></a>1.7. CORS</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux lets you handle CORS (Cross-Origin Resource Sharing). This section
describes how to do so.</p>
</div>
<div class="sect3">
<h4 id="webflux-cors-intro"><a class="anchor" href="#webflux-cors-intro"></a>1.7.1. Introduction</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-intro">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>For security reasons, browsers prohibit AJAX calls to resources outside the current origin.
For example, you could have your bank account in one tab and evil.com in another. Scripts
from evil.com should not be able to make AJAX requests to your bank API with your
credentials&#8201;&#8212;&#8201;for example, withdrawing money from your account!</p>
</div>
<div class="paragraph">
<p>Cross-Origin Resource Sharing (CORS) is a <a href="http://www.w3.org/TR/cors/">W3C specification</a>
implemented by <a href="http://caniuse.com/#feat=cors">most browsers</a> that lets you specify
what kind of cross-domain requests are authorized, rather than using less secure and less
powerful workarounds based on IFRAME or JSONP.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-processing"><a class="anchor" href="#webflux-cors-processing"></a>1.7.2. Processing</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-processing">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The CORS specification distinguishes between preflight, simple, and actual requests.
To learn how CORS works, you can read
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">this article</a>, among
many others, or see the specification for more details.</p>
</div>
<div class="paragraph">
<p>Spring WebFlux <code>HandlerMapping</code> implementations provide built-in support for CORS. After successfully
mapping a request to a handler, a <code>HandlerMapping</code> checks the CORS configuration for the
given request and handler and takes further actions. Preflight requests are handled
directly, while simple and actual CORS requests are intercepted, validated, and have the
required CORS response headers set.</p>
</div>
<div class="paragraph">
<p>In order to enable cross-origin requests (that is, the <code>Origin</code> header is present and
differs from the host of the request), you need to have some explicitly declared CORS
configuration. If no matching CORS configuration is found, preflight requests are
rejected. No CORS headers are added to the responses of simple and actual CORS requests
and, consequently, browsers reject them.</p>
</div>
<div class="paragraph">
<p>Each <code>HandlerMapping</code> can be
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-">configured</a>
individually with URL pattern-based <code>CorsConfiguration</code> mappings. In most cases, applications
use the WebFlux Java configuration to declare such mappings, which results in a single,
global map passed to all <code>HadlerMappping</code> implementations.</p>
</div>
<div class="paragraph">
<p>You can combine global CORS configuration at the <code>HandlerMapping</code> level with more
fine-grained, handler-level CORS configuration. For example, annotated controllers can use
class- or method-level <code>@CrossOrigin</code> annotations (other handlers can implement
<code>CorsConfigurationSource</code>).</p>
</div>
<div class="paragraph">
<p>The rules for combining global and local configuration are generally additive&#8201;&#8212;&#8201;for example,
all global and all local origins. For those attributes where only a single value can be
accepted, such as <code>allowCredentials</code> and <code>maxAge</code>, the local overrides the global value. See
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-"><code>CorsConfiguration#combine(CorsConfiguration)</code></a>
for more details.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To learn more from the source or to make advanced customizations, see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CorsConfiguration</code></p>
</li>
<li>
<p><code>CorsProcessor</code> and <code>DefaultCorsProcessor</code></p>
</li>
<li>
<p><code>AbstractHandlerMapping</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-controller"><a class="anchor" href="#webflux-cors-controller"></a>1.7.3. <code>@CrossOrigin</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-controller">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>
annotation enables cross-origin requests on annotated controller methods, as the
following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/account</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AccountController</span> {

    <span class="annotation">@CrossOrigin</span>
    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;Account&gt; retrieve(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@DeleteMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; remove(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, <code>@CrossOrigin</code> allows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All origins.</p>
</li>
<li>
<p>All headers.</p>
</li>
<li>
<p>All HTTP methods to which the controller method is mapped.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>allowedCredentials</code> is not enabled by default, since that establishes a trust level
that exposes sensitive user-specific information (such as cookies and CSRF tokens) and
should be used only where appropriate.</p>
</div>
<div class="paragraph">
<p><code>maxAge</code> is set to 30 minutes.</p>
</div>
<div class="paragraph">
<p><code>@CrossOrigin</code> is supported at the class level, too, and inherited by all methods.
The following example specifies a certain domain and sets <code>maxAge</code> to an hour:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CrossOrigin</span>(origins = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain2.com</span><span class="delimiter">&quot;</span></span>, maxAge = <span class="integer">3600</span>)
<span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/account</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AccountController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;Account&gt; retrieve(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@DeleteMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; remove(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use <code>@CrossOrigin</code> at both the class and the method level,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@CrossOrigin</span>(maxAge = <span class="integer">3600</span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/account</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AccountController</span> {

    <span class="annotation">@CrossOrigin</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain2.com</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;Account&gt; retrieve(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }

    <span class="annotation">@DeleteMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; remove(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@CrossOrigin</code> at the class level.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using <code>@CrossOrigin</code> at the method level.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-global"><a class="anchor" href="#webflux-cors-global"></a>1.7.4. Global Configuration</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-global">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>In addition to fine-grained, controller method-level configuration, you probably want to
define some global CORS configuration, too. You can set URL-based <code>CorsConfiguration</code>
mappings individually on any <code>HandlerMapping</code>. Most applications, however, use the
WebFlux Java configuration to do that.</p>
</div>
<div class="paragraph">
<p>By default global configuration enables the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All origins.</p>
</li>
<li>
<p>All headers.</p>
</li>
<li>
<p><code>GET</code>, <code>HEAD</code>, and <code>POST</code> methods.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>allowedCredentials</code> is not enabled by default, since that establishes a trust level
that exposes sensitive user-specific information( such as cookies and CSRF tokens) and
should be used only where appropriate.</p>
</div>
<div class="paragraph">
<p><code>maxAge</code> is set to 30 minutes.</p>
</div>
<div class="paragraph">
<p>To enable CORS in the WebFlux Java configuration, you can use the <code>CorsRegistry</code> callback,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addCorsMappings(CorsRegistry registry) {

        registry.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">/api/**</span><span class="delimiter">&quot;</span></span>)
            .allowedOrigins(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain2.com</span><span class="delimiter">&quot;</span></span>)
            .allowedMethods(<span class="string"><span class="delimiter">&quot;</span><span class="content">PUT</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">DELETE</span><span class="delimiter">&quot;</span></span>)
            .allowedHeaders(<span class="string"><span class="delimiter">&quot;</span><span class="content">header1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">header2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">header3</span><span class="delimiter">&quot;</span></span>)
            .exposedHeaders(<span class="string"><span class="delimiter">&quot;</span><span class="content">header1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">header2</span><span class="delimiter">&quot;</span></span>)
            .allowCredentials(<span class="predefined-constant">true</span>).maxAge(<span class="integer">3600</span>);

        <span class="comment">// Add more mappings...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-webfilter"><a class="anchor" href="#webflux-cors-webfilter"></a>1.7.5. CORS <code>WebFilter</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-filter">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can apply CORS support through the built-in
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsWebFilter.html"><code>CorsWebFilter</code></a>, which is a
good fit with <a href="#webflux-fn">functional endpoints</a>.</p>
</div>
<div class="paragraph">
<p>To configure the filter, you can declare a <code>CorsWebFilter</code> bean and pass a
<code>CorsConfigurationSource</code> to its constructor, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
CorsWebFilter corsFilter() {

    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();

    <span class="comment">// Possibly...</span>
    <span class="comment">// config.applyPermitDefaultValues()</span>

    config.setAllowCredentials(<span class="predefined-constant">true</span>);
    config.addAllowedOrigin(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain1.com</span><span class="delimiter">&quot;</span></span>);
    config.addAllowedHeader(<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span>);
    config.addAllowedMethod(<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span>);

    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration(<span class="string"><span class="delimiter">&quot;</span><span class="content">/**</span><span class="delimiter">&quot;</span></span>, config);

    <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-web-security"><a class="anchor" href="#webflux-web-security"></a>1.8. Web Security</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-web-security">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <a href="http://projects.spring.io/spring-security/">Spring Security</a> project provides support
for protecting web applications from malicious exploits. See the Spring Security
reference documentation, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#jc-webflux">WebFlux Security</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-webflux">WebFlux Testing Support</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF Protection</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">Security Response Headers</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="webflux-view"><a class="anchor" href="#webflux-view"></a>1.9. View Technologies</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The use of view technologies in Spring WebFlux is pluggable. Whether you decide to
use Thymeleaf, FreeMarker, or some other view technology is primarily a matter of a
configuration change. This chapter covers the view technologies integrated with Spring
WebFlux. We assume you are already familiar with <a href="#webflux-viewresolution">View Resolution</a>.</p>
</div>
<div class="sect3">
<h4 id="webflux-view-thymeleaf"><a class="anchor" href="#webflux-view-thymeleaf"></a>1.9.1. Thymeleaf</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-thymeleaf">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Thymeleaf is a modern server-side Java template engine that emphasizes natural HTML
templates that can be previewed in a browser by double-clicking, which is very
helpful for independent work on UI templates (for example, by a designer) without the need for a
running server. Thymeleaf offers an extensive set of features, and it is actively developed
and maintained. For a more complete introduction, see the
<a href="http://www.thymeleaf.org/">Thymeleaf</a> project home page.</p>
</div>
<div class="paragraph">
<p>The Thymeleaf integration with Spring WebFlux is managed by the Thymeleaf project. The
configuration involves a few bean declarations, such as
<code>SpringResourceTemplateResolver</code>, <code>SpringWebFluxTemplateEngine</code>, and
<code>ThymeleafReactiveViewResolver</code>. For more details, see
<a href="http://www.thymeleaf.org/documentation.html">Thymeleaf+Spring</a> and the WebFlux integration
<a href="http://forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html">announcement</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-freemarker"><a class="anchor" href="#webflux-view-freemarker"></a>1.9.2. FreeMarker</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-freemarker">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://www.freemarker.org">Apache FreeMarker</a> is a template engine for generating any
kind of text output from HTML to email and others. The Spring Framework has a built-in
integration for using Spring WebFlux with FreeMarker templates.</p>
</div>
<div class="sect4">
<h5 id="webflux-view-freemarker-contextconfig"><a class="anchor" href="#webflux-view-freemarker-contextconfig"></a>View Configuration</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-freemarker-contextconfig">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following example shows how to configure FreeMarker as a view technology:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        registry.freemarker();
    }

    <span class="comment">// Configure FreeMarker...</span>

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/templates</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> configurer;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Your templates need to be stored in the directory specified by the <code>FreeMarkerConfigurer</code>,
shown in the preceding example. Given the preceding configuration, if your controller returns the view name,
<code>welcome</code>, the resolver looks for the
<code>classpath:/templates/freemarker/welcome.ftl</code> template.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-views-freemarker"><a class="anchor" href="#webflux-views-freemarker"></a>FreeMarker Configuration</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-views-freemarker">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can pass FreeMarker 'Settings' and 'SharedVariables' directly to the FreeMarker
<code>Configuration</code> object (managed by Spring) by setting the appropriate bean properties on
the <code>FreeMarkerConfigurer</code> bean. The <code>freemarkerSettings</code> property requires a
<code>java.util.Properties</code> object, and the <code>freemarkerVariables</code> property requires a
<code>java.util.Map</code>. The following example shows how to use a <code>FreeMarkerConfigurer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="comment">// ...</span>

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer() {
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; variables = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();
        variables.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">xml_escape</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> XmlEscape());

        FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/templates</span><span class="delimiter">&quot;</span></span>);
        configurer.setFreemarkerVariables(variables);
        <span class="keyword">return</span> configurer;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the FreeMarker documentation for details of settings and variables as they apply to
the <code>Configuration</code> object.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-script"><a class="anchor" href="#webflux-view-script"></a>1.9.3. Script Views</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The Spring Framework has a built-in integration for using Spring WebFlux with any
templating library that can run on top of the
<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java scripting engine.
The following table shows the templating libraries that we have tested on different script engines:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Scripting Library</th>
<th class="tableblock halign-left valign-top">Scripting Engine</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://handlebarsjs.com/">Handlebars</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://mustache.github.io/">Mustache</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://facebook.github.io/react/">React</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.embeddedjs.com/">EJS</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.stuartellis.eu/articles/erb/">ERB</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://jruby.org">JRuby</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.python.org/2/library/string.html#template-strings">String templates</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.jython.org/">Jython</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin Script templating</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://kotlinlang.org/">Kotlin</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The basic rule for integrating any other script engine is that it must implement the
<code>ScriptEngine</code> and <code>Invocable</code> interfaces.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="webflux-view-script-dependencies"><a class="anchor" href="#webflux-view-script-dependencies"></a>Requirements</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script-dependencies">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You need to have the script engine on your classpath, the details of which vary by script engine:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a> JavaScript engine is provided with
Java 8+. Using the latest update release available is highly recommended.</p>
</li>
<li>
<p><a href="http://jruby.org">JRuby</a> should be added as a dependency for Ruby support.</p>
</li>
<li>
<p><a href="http://www.jython.org">Jython</a> should be added as a dependency for Python support.</p>
</li>
<li>
<p><code>org.jetbrains.kotlin:kotlin-script-util</code> dependency and a <code>META-INF/services/javax.script.ScriptEngineFactory</code>
file containing a <code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code>
line should be added for Kotlin script support. See
<a href="https://github.com/sdeleuze/kotlin-script-templating">this example</a> for more detail.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to have the script templating library. One way to do that for Javascript is
through <a href="http://www.webjars.org/">WebJars</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-view-script-integrate"><a class="anchor" href="#webflux-view-script-integrate"></a>Script Templates</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script-integrate">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can declare a <code>ScriptTemplateConfigurer</code> bean to specify the script engine to use,
the script files to load, what function to call to render templates, and so on.
The following example uses Mustache templates and the Nashorn JavaScript engine:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = <span class="keyword">new</span> ScriptTemplateConfigurer();
        configurer.setEngineName(<span class="string"><span class="delimiter">&quot;</span><span class="content">nashorn</span><span class="delimiter">&quot;</span></span>);
        configurer.setScripts(<span class="string"><span class="delimiter">&quot;</span><span class="content">mustache.js</span><span class="delimiter">&quot;</span></span>);
        configurer.setRenderObject(<span class="string"><span class="delimiter">&quot;</span><span class="content">Mustache</span><span class="delimiter">&quot;</span></span>);
        configurer.setRenderFunction(<span class="string"><span class="delimiter">&quot;</span><span class="content">render</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> configurer;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>render</code> function is called with the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String template</code>: The template content</p>
</li>
<li>
<p><code>Map model</code>: The view model</p>
</li>
<li>
<p><code>RenderingContext renderingContext</code>: The
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html"><code>RenderingContext</code></a>
that gives access to the application context, the locale, the template loader, and the
URL (since 5.0)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Mustache.render()</code> is natively compatible with this signature, so you can call it directly.</p>
</div>
<div class="paragraph">
<p>If your templating technology requires some customization, you can provide a script that
implements a custom render function. For example, <a href="http://handlebarsjs.com">Handlerbars</a>
needs to compile templates before using them and requires a
<a href="http://en.wikipedia.org/wiki/Polyfill">polyfill</a> in order to emulate some
browser facilities not available in the server-side script engine.
The following example shows how to set a custom render function:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebMvc</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = <span class="keyword">new</span> ScriptTemplateConfigurer();
        configurer.setEngineName(<span class="string"><span class="delimiter">&quot;</span><span class="content">nashorn</span><span class="delimiter">&quot;</span></span>);
        configurer.setScripts(<span class="string"><span class="delimiter">&quot;</span><span class="content">polyfill.js</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">handlebars.js</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">render.js</span><span class="delimiter">&quot;</span></span>);
        configurer.setRenderFunction(<span class="string"><span class="delimiter">&quot;</span><span class="content">render</span><span class="delimiter">&quot;</span></span>);
        configurer.setSharedEngine(<span class="predefined-constant">false</span>);
        <span class="keyword">return</span> configurer;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Setting the <code>sharedEngine</code> property to <code>false</code> is required when using non-thread-safe
script engines with templating libraries not designed for concurrency, such as Handlebars or
React running on Nashorn. In that case, Java 8u60 or greater is required, due
to <a href="https://bugs.openjdk.java.net/browse/JDK-8076099">this bug</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>polyfill.js</code> defines only the <code>window</code> object needed by Handlebars to run properly,
as the following snippet shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">var</span> window = {};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This basic <code>render.js</code> implementation compiles the template before using it. A production
ready implementation should also store and reused cached templates or pre-compiled templates.
This can be done on the script side, as well as any customization you need (managing
template engine configuration for example).
The following example shows how compile a template:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="keyword">function</span> <span class="function">render</span>(template, model) {
    <span class="keyword">var</span> compiledTemplate = Handlebars.compile(template);
    <span class="keyword">return</span> compiledTemplate(model);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Check out the Spring Framework unit tests,
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script">Java</a>, and
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script">resources</a>,
for more configuration examples.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-httpmessagewriter"><a class="anchor" href="#webflux-view-httpmessagewriter"></a>1.9.4. JSON and XML</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-jackson">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>For <a href="#webflux-multiple-representations">Content Negotiation</a> purposes, it is useful to be able to alternate
between rendering a model with an HTML template or as other formats (such as JSON or XML),
depending on the content type requested by the client. To support doing so, Spring WebFlux
provides the <code>HttpMessageWriterView</code>, which you can use to plug in any of the available
<a href="#webflux-codecs">Codecs</a> from <code>spring-web</code>, such as <code>Jackson2JsonEncoder</code>,
<code>Jackson2SmileEncoder</code>, or <code>Jaxb2XmlEncoder</code>.</p>
</div>
<div class="paragraph">
<p>Unlike other view technologies, <code>HttpMessageWriterView</code> does not require a <code>ViewResolver</code>
but is instead <a href="#webflux-config-view-resolvers">configured</a> as a default view. You can
configure one or more such default views, wrapping different <code>HttpMessageWriter</code> instances or
<code>Encoder</code> instances. The one that matches the requested content type is used at runtime.</p>
</div>
<div class="paragraph">
<p>In most cases, a model contains multiple attributes. To determine which one
to serialize, you can configure <code>HttpMessageWriterView</code> with the name of the model
attribute to use for rendering. If the model contains only one attribute, that one is used.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-caching"><a class="anchor" href="#webflux-caching"></a>1.10. HTTP Caching</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>HTTP caching can significantly improve the performance of a web application. HTTP caching
revolves around the <code>Cache-Control</code> response header and subsequent conditional request
headers, such as <code>Last-Modified</code> and <code>ETag</code>. <code>Cache-Control</code> advises private (for example, browser)
and public (for example, proxy) caches how to cache and re-use responses. An <code>ETag</code> header is used
to make a conditional request that may result in a 304 (NOT_MODIFIED) without a body,
if the content has not changed. <code>ETag</code> can be seen as a more sophisticated successor to
the <code>Last-Modified</code> header.</p>
</div>
<div class="paragraph">
<p>This section describes the HTTP caching related options available in Spring WebFlux.</p>
</div>
<div class="sect3">
<h4 id="webflux-caching-cachecontrol"><a class="anchor" href="#webflux-caching-cachecontrol"></a>1.10.1. <code>CacheControl</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-cachecontrol">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/http/CacheControl.html"><code>CacheControl</code></a> provides support for
configuring settings related to the <code>Cache-Control</code> header and is accepted as an argument
in a number of places:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-caching-etag-lastmodified">Controllers</a></p>
</li>
<li>
<p><a href="#webflux-caching-static-resources">Static Resources</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While <a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a> describes all possible
directives for the <code>Cache-Control</code> response header, the <code>CacheControl</code> type takes a
use case-oriented approach that focuses on the common scenarios, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Cache for an hour - &quot;Cache-Control: max-age=3600&quot;</span>
CacheControl ccCacheOneHour = CacheControl.maxAge(<span class="integer">1</span>, <span class="predefined-type">TimeUnit</span>.HOURS);

<span class="comment">// Prevent caching - &quot;Cache-Control: no-store&quot;</span>
CacheControl ccNoStore = CacheControl.noStore();

<span class="comment">// Cache for ten days in public and private caches,</span>
<span class="comment">// public caches should not transform the response</span>
<span class="comment">// &quot;Cache-Control: max-age=864000, public, no-transform&quot;</span>
CacheControl ccCustom = CacheControl.maxAge(<span class="integer">10</span>, <span class="predefined-type">TimeUnit</span>.DAYS).noTransform().cachePublic();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-caching-etag-lastmodified"><a class="anchor" href="#webflux-caching-etag-lastmodified"></a>1.10.2. Controllers</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-etag-lastmodified">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Controllers can add explicit support for HTTP caching. We recommend doing so, since the
<code>lastModified</code> or <code>ETag</code> value for a resource needs to be calculated before it can be compared
against conditional request headers. A controller can add an <code>ETag</code> and <code>Cache-Control</code>
settings to a <code>ResponseEntity</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@GetMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/book/{id}</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> ResponseEntity&lt;<span class="predefined-type">Book</span>&gt; showBook(<span class="annotation">@PathVariable</span> <span class="predefined-type">Long</span> id) {

    <span class="predefined-type">Book</span> book = findBook(id);
    <span class="predefined-type">String</span> version = book.getVersion();

    <span class="keyword">return</span> ResponseEntity
            .ok()
            .cacheControl(CacheControl.maxAge(<span class="integer">30</span>, <span class="predefined-type">TimeUnit</span>.DAYS))
            .eTag(version) <span class="comment">// lastModified is also available</span>
            .body(book);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example sends a 304 (NOT_MODIFIED) response with an empty body if the comparison
to the conditional request headers indicates the content has not changed. Otherwise, the
<code>ETag</code> and <code>Cache-Control</code> headers are added to the response.</p>
</div>
<div class="paragraph">
<p>You can also make the check against conditional request headers in the controller,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestMapping</span>
<span class="directive">public</span> <span class="predefined-type">String</span> myHandleMethod(ServerWebExchange exchange, Model model) {

    <span class="type">long</span> eTag = ... <i class="conum" data-value="1"></i><b>(1)</b>

    if (exchange.checkNotModified(eTag)) {
        <span class="keyword">return</span> <span class="predefined-constant">null</span>; <i class="conum" data-value="2"></i><b>(2)</b>
    }

    model.addAttribute(...); <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">myViewName</span><span class="delimiter">&quot;</span></span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Application-specific calculation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Response has been set to 304 (NOT_MODIFIED). No further processing.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Continue with request processing.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>There are three variants for checking conditional requests against <code>eTag</code> values, <code>lastModified</code>
values, or both. For conditional <code>GET</code> and <code>HEAD</code> requests, you can set the response to
304 (NOT_MODIFIED). For conditional <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>, you can instead set the response
to 409 (PRECONDITION_FAILED) to prevent concurrent modification.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-caching-static-resources"><a class="anchor" href="#webflux-caching-static-resources"></a>1.10.3. Static Resources</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-static-resources">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You should serve static resources with a <code>Cache-Control</code> and conditional response headers
for optimal performance. See the section on configuring <a href="#webflux-config-static-resources">Static Resources</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config"><a class="anchor" href="#webflux-config"></a>1.11. WebFlux Config</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The WebFlux Java configuration declares the components that are required to process requests with annotated
controllers or functional endpoints, and it offers an API to customize the configuration.
That means you do not need to understand the underlying beans created by the Java configuration.
However, if you want to understand them, you can see them in <code>WebFluxConfigurationSupport</code> or read more
about what they are in <a href="#webflux-special-bean-types">Special Bean Types</a>.</p>
</div>
<div class="paragraph">
<p>For more advanced customizations, not available in the configuration API, you can
gain full control over the configuration through the
<a href="#webflux-config-advanced-java">Advanced Configuration Mode</a>.</p>
</div>
<div class="sect3">
<h4 id="webflux-config-enable"><a class="anchor" href="#webflux-config-enable"></a>1.11.1. Enabling WebFlux Config</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-enable">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@EnableWebFlux</code> annotation in your Java config, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example registers a number of Spring WebFlux
<a href="#mvc-webflux-special-bean-types">infrastructure beans</a> and adapts to dependencies
available on the classpath&#8201;&#8212;&#8201;for JSON, XML, and others.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-customize"><a class="anchor" href="#webflux-config-customize"></a>1.11.2. WebFlux config API</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-customize">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>In your Java configuration, you can implement the <code>WebFluxConfigurer</code> interface,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="comment">// Implement configuration methods...</span>

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-conversion"><a class="anchor" href="#webflux-config-conversion"></a>1.11.3. Conversion, formatting</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-conversion">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>By default, formatters for <code>Number</code> and <code>Date</code> types are installed, including support for
the <code>@NumberFormat</code> and <code>@DateTimeFormat</code> annotations. Full support for the Joda-Time
formatting library is also installed if Joda-Time is present on the classpath.</p>
</div>
<div class="paragraph">
<p>The following example shows how to register custom formatters and converters:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addFormatters(FormatterRegistry registry) {
        <span class="comment">// ...</span>
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See <a href="core.html#format-FormatterRegistrar-SPI"><code>FormatterRegistrar</code> SPI</a>
and the <code>FormattingConversionServiceFactoryBean</code> for more information on when to use <code>FormatterRegistrar</code> implementations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-validation"><a class="anchor" href="#webflux-config-validation"></a>1.11.4. Validation</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-validation">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>By default, if <a href="core.html#validation-beanvalidation-overview">Bean Validation</a> is present
on the classpath (for example, the Hibernate Validator), the <code>LocalValidatorFactoryBean</code> is registered
as a global <a href="core.html#validator">validator</a> for use with <code>@Valid</code> and <code>Validated</code> on
<code>@Controller</code> method arguments.</p>
</div>
<div class="paragraph">
<p>In your Java configuration, you can customize the global <code>Validator</code> instance,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Validator</span> getValidator(); {
        <span class="comment">// ...</span>
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that you can also register <code>Validator</code> implementations locally,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> {

    <span class="annotation">@InitBinder</span>
    <span class="directive">protected</span> <span class="type">void</span> initBinder(WebDataBinder binder) {
        binder.addValidators(<span class="keyword">new</span> FooValidator());
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you need to have a <code>LocalValidatorFactoryBean</code> injected somewhere, create a bean and
mark it with <code>@Primary</code> in order to avoid conflict with the one declared in the MVC config.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-content-negotiation"><a class="anchor" href="#webflux-config-content-negotiation"></a>1.11.5. Content Type Resolvers</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-content-negotiation">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can configure how Spring WebFlux determines the requested media types for
<code>@Controller</code> instances from the request. By default, only the <code>Accept</code> header is checked, but you
can also enable a query parameter-based strategy.</p>
</div>
<div class="paragraph">
<p>The following example shows how to customize the requested content type resolution:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-message-codecs"><a class="anchor" href="#webflux-config-message-codecs"></a>1.11.6. HTTP message codecs</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-message-converters">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following example shows how to customize how the request and response body are read and written:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ServerCodecConfigurer</code> provides a set of default readers and writers. You can use it to add
more readers and writers, customize the default ones, or replace the default ones completely.</p>
</div>
<div class="paragraph">
<p>For Jackson JSON and XML, consider using
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a>,
which customizes Jackson&#8217;s default properties with the following ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a> is disabled.</p>
</li>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a> is disabled.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It also automatically registers the following well-known modules if they are detected on the classpath:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk7"><code>jackson-datatype-jdk7</code></a>: Support for Java 7 types like <code>java.nio.file.Path</code>.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda"><code>jackson-datatype-joda</code></a>: Support for Joda-Time types.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310"><code>jackson-datatype-jsr310</code></a>: Support for Java 8 Date and Time API types.</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8"><code>jackson-datatype-jdk8</code></a>: Support for other Java 8 types, such as <code>Optional</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-view-resolvers"><a class="anchor" href="#webflux-config-view-resolvers"></a>1.11.7. View Resolvers</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-view-resolvers">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following example shows how to configure view resolution:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>ViewResolverRegistry</code> has shortcuts for view technologies with which the Spring Framework
integrates. The following example uses FreeMarker (which also requires configuring the
underlying FreeMarker view technology):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {


    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
    }

    <span class="comment">// Configure Freemarker...</span>

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/templates</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> configurer;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also plug in any <code>ViewResolver</code> implementation, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {


    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        ViewResolver resolver = ... ;
        registry.viewResolver(resolver);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To support <a href="#webflux-multiple-representations">Content Negotiation</a> and rendering other formats
through view resolution (besides HTML), you can configure one or more default views based
on the <code>HttpMessageWriterView</code> implementation, which accepts any of the available
<a href="#webflux-codecs">Codecs</a> from <code>spring-web</code>. The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {


    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();

        Jackson2JsonEncoder encoder = <span class="keyword">new</span> Jackson2JsonEncoder();
        registry.defaultViews(<span class="keyword">new</span> HttpMessageWriterView(encoder));
    }

    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#webflux-view">View Technologies</a> for more on the view technologies that are integrated with Spring WebFlux.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-static-resources"><a class="anchor" href="#webflux-config-static-resources"></a>1.11.8. Static Resources</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-static-resources">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>This option provides a convenient way to serve static resources from a list of
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/core/io/Resource.html"><code>Resource</code></a>-based locations.</p>
</div>
<div class="paragraph">
<p>In the next example, given a request that starts with <code>/resources</code>, the relative path is
used to find and serve static resources relative to <code>/static</code> on the classpath. Resources
are served with a one-year future expiration to ensure maximum use of the browser cache
and a reduction in HTTP requests made by the browser. The <code>Last-Modified</code> header is also
evaluated and, if present, a <code>304</code> status code is returned. The following list shows
the example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resources/**</span><span class="delimiter">&quot;</span></span>)
            .addResourceLocations(<span class="string"><span class="delimiter">&quot;</span><span class="content">/public</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/static/</span><span class="delimiter">&quot;</span></span>)
            .setCacheControl(CacheControl.maxAge(<span class="integer">365</span>, <span class="predefined-type">TimeUnit</span>.DAYS));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The resource handler also supports a chain of
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceResolver.html"><code>ResourceResolver</code></a> implementations and
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a> implementations,
which can be used to create a toolchain for working with optimized resources.</p>
</div>
<div class="paragraph">
<p>You can use the <code>VersionResourceResolver</code> for versioned resource URLs based on an MD5 hash
computed from the content, a fixed application version, or other information. A
<code>ContentVersionStrategy</code> (MD5 hash) is a good choice with some notable exceptions (such as
JavaScript resources used with a module loader).</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>VersionResourceResolver</code> in your Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/resources/**</span><span class="delimiter">&quot;</span></span>)
                .addResourceLocations(<span class="string"><span class="delimiter">&quot;</span><span class="content">/public/</span><span class="delimiter">&quot;</span></span>)
                .resourceChain(<span class="predefined-constant">true</span>)
                .addResolver(<span class="keyword">new</span> VersionResourceResolver().addContentVersionStrategy(<span class="string"><span class="delimiter">&quot;</span><span class="content">/**</span><span class="delimiter">&quot;</span></span>));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use <code>ResourceUrlProvider</code> to rewrite URLs and apply the full chain of resolvers and
transformers (for example, to insert versions). The WebFlux configuration provides a <code>ResourceUrlProvider</code>
so that it can be injected into others.</p>
</div>
<div class="paragraph">
<p>Unlike Spring MVC, at present, in WebFlux, there is no way to transparently rewrite static
resource URLs, since there are no view technologies that can make use of a non-blocking chain
of resolvers and transformers. When serving only local resources, the workaround is to use
<code>ResourceUrlProvider</code> directly (for example, through a custom element) and block.</p>
</div>
<div class="paragraph">
<p>Note that, when using both <code>EncodedResourceResolver</code> (for example, Gzip, Brotli encoded) and
<code>VersionedResourceResolver</code>, they must be registered in that order, to ensure content-based
versions are always computed reliably based on the unencoded file.</p>
</div>
<div class="paragraph">
<p><a href="http://www.webjars.org/documentation">WebJars</a> is also supported through <code>WebJarsResourceResolver</code>
and is automatically registered when <code>org.webjars:webjars-locator</code> is present on the
classpath. The resolver can re-write URLs to include the version of the jar and can also
match to incoming URLs without versions (for example, <code>/jquery/jquery.min.js</code> to
<code>/jquery/1.2.0/jquery.min.js</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-path-matching"><a class="anchor" href="#webflux-config-path-matching"></a>1.11.9. Path Matching</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-path-matching">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can customize options related to path matching. For details on the individual options, see the
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/reactive/config/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> javadoc.
The following example shows how to use <code>PathMatchConfigurer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebFlux</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">implements</span> WebFluxConfigurer {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configurePathMatch(PathMatchConfigurer configurer) {
        configurer
            .setUseCaseSensitiveMatch(<span class="predefined-constant">true</span>)
            .setUseTrailingSlashMatch(<span class="predefined-constant">false</span>)
            .addPathPrefix(<span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span>,
                    HandlerTypePredicate.forAnnotation(RestController.class));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring WebFlux relies on a parsed representation of the request path called
<code>RequestPath</code> for access to decoded path segment values, with semicolon content removed
(that is, path or matrix variables). That means, unlike in Spring MVC, you need not indicate
whether to decode the request path nor whether to remove semicolon content for
path matching purposes.</p>
</div>
<div class="paragraph">
<p>Spring WebFlux also does not support suffix pattern matching, unlike in Spring MVC, where we
are also <a href="web.html#mvc-ann-requestmapping-suffix-pattern-match">recommend</a> moving away from
reliance on it.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-advanced-java"><a class="anchor" href="#webflux-config-advanced-java"></a>1.11.10. Advanced Configuration Mode</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-advanced-java">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebFlux</code> imports <code>DelegatingWebFluxConfiguration</code> that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provides default Spring configuration for WebFlux applications</p>
</li>
<li>
<p>detects and delegates to <code>WebFluxConfigurer</code> implementations to customize that configuration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For advanced mode, you can remove <code>@EnableWebFlux</code> and extend directly from
<code>DelegatingWebFluxConfiguration</code> instead of implementing <code>WebFluxConfigurer</code>,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">WebConfig</span> <span class="directive">extends</span> DelegatingWebFluxConfiguration {

    <span class="comment">// ...</span>

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can keep existing methods in <code>WebConfig</code>, but you can now also override bean declarations
from the base class and still have any number of other <code>WebMvcConfigurer</code> implementations on
the classpath.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-http2"><a class="anchor" href="#webflux-http2"></a>1.12. HTTP/2</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-http2">Same as in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>Servlet 4 containers are required to support HTTP/2, and Spring Framework 5 is compatible
with Servlet API 4. From a programming model perspective, there is nothing specific that
applications need to do. However, there are considerations related to server configuration.
For more details, see the
<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 wiki page</a>.</p>
</div>
<div class="paragraph">
<p>Currently, Spring WebFlux does not support HTTP/2 with Netty. There is also no support for
pushing resources programmatically to the client.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-client"><a class="anchor" href="#webflux-client"></a>2. WebClient</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring WebFlux includes a reactive, non-blocking <code>WebClient</code> for HTTP requests. The client
has a functional, fluent API with reactive types for declarative composition, see
<a href="#webflux-reactive-libraries">Reactive Libraries</a>. WebFlux client and server rely on the
same non-blocking <a href="#webflux-codecs">codecs</a> to encode and decode request
and response content.</p>
</div>
<div class="paragraph">
<p>Internally <code>WebClient</code> delegates to an HTTP client library. By default, it uses
<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>, there is built-in support for
the Jetty <a href="https://github.com/jetty-project/jetty-reactive-httpclient">reactive HttpClient</a>,
and others can be plugged in through a <code>ClientHttpConnector</code>.</p>
</div>
<div class="sect2">
<h3 id="webflux-client-builder"><a class="anchor" href="#webflux-client-builder"></a>2.1. Configuration</h3>
<div class="paragraph">
<p>The simplest way to create a <code>WebClient</code> is through one of the static factory methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>WebClient.create()</code></p>
</li>
<li>
<p><code>WebClient.create(String baseUrl)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The above methods use the Reactor Netty <code>HttpClient</code> with default settings and expect
<code>io.projectreactor.netty:reactor-netty</code> to be on the classpath.</p>
</div>
<div class="paragraph">
<p>You can also use <code>WebClient.builder()</code> with further options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>uriBuilderFactory</code>: Customized <code>UriBuilderFactory</code> to use as a base URL.</p>
</li>
<li>
<p><code>defaultHeader</code>: Headers for every request.</p>
</li>
<li>
<p><code>defaultCookie</code>: Cookies for every request.</p>
</li>
<li>
<p><code>defaultRequest</code>: <code>Consumer</code> to customize every request.</p>
</li>
<li>
<p><code>filter</code>: Client filter for every request.</p>
</li>
<li>
<p><code>exchangeStrategies</code>: HTTP message reader/writer customizations.</p>
</li>
<li>
<p><code>clientConnector</code>: HTTP client library settings.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example configures <a href="#webflux-codecs">HTTP codecs</a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    ExchangeStrategies strategies = ExchangeStrategies.builder()
            .codecs(configurer -&gt; {
                <span class="comment">// ...</span>
            })
            .build();

    WebClient client = WebClient.builder()
            .exchangeStrategies(strategies)
            .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once built, a <code>WebClient</code> instance is immutable. However, you can clone it and build a
modified copy without affecting the original instance, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    WebClient client1 = WebClient.builder()
            .filter(filterA).filter(filterB).build();

    WebClient client2 = client1.mutate()
            .filter(filterC).filter(filterD).build();

    <span class="comment">// client1 has filterA, filterB</span>

    <span class="comment">// client2 has filterA, filterB, filterC, filterD</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-reactor"><a class="anchor" href="#webflux-client-builder-reactor"></a>2.1.1. Reactor Netty</h4>
<div class="paragraph">
<p>To customize Reactor Netty settings, simple provide a pre-configured <code>HttpClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    HttpClient httpClient = HttpClient.create().secure(sslSpec -&gt; ...);

    WebClient webClient = WebClient.builder()
            .clientConnector(<span class="keyword">new</span> ReactorClientHttpConnector(httpClient))
            .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-client-builder-reactor-resources"><a class="anchor" href="#webflux-client-builder-reactor-resources"></a>Resources</h5>
<div class="paragraph">
<p>By default, <code>HttpClient</code> participates in the global Reactor Netty resources held in
<code>reactor.netty.http.HttpResources</code>, including event loop threads and a connection pool.
This is the recommended mode, since fixed, shared resources are preferred for event loop
concurrency. In this mode global resources remain active until the process exits.</p>
</div>
<div class="paragraph">
<p>If the server is timed with the process, there is typically no need for an explicit
shutdown. However, if the server can start or stop in-process (for example, a Spring MVC
application deployed as a WAR), you can declare a Spring-managed bean of type
<code>ReactorResourceFactory</code> with <code>globalResources=true</code> (the default) to ensure that the Reactor
Netty global resources are shut down when the Spring <code>ApplicationContext</code> is closed,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Bean</span>
    <span class="directive">public</span> ReactorResourceFactory reactorResourceFactory() {
        <span class="keyword">return</span> <span class="keyword">new</span> ReactorResourceFactory();
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also choose not to participate in the global Reactor Netty resources. However,
in this mode, the burden is on you to ensure that all Reactor Netty client and server
instances use shared resources, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Bean</span>
    <span class="directive">public</span> ReactorResourceFactory resourceFactory() {
        ReactorResourceFactory factory = <span class="keyword">new</span> ReactorResourceFactory();
        factory.setGlobalResources(<span class="predefined-constant">false</span>); <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> factory;
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> WebClient webClient() {

        Function&lt;HttpClient, HttpClient&gt; mapper = client -&gt; {
            <span class="comment">// Further customizations...</span>
        };

        ClientHttpConnector connector =
                <span class="keyword">new</span> ReactorClientHttpConnector(resourceFactory(), mapper); <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="keyword">return</span> WebClient.builder().clientConnector(connector).build(); <i class="conum" data-value="3"></i><b>(3)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create resources independent of global ones.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use the <code>ReactorClientHttpConnector</code> constructor with resource factory.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Plug the connector into the <code>WebClient.Builder</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-client-builder-reactor-timeout"><a class="anchor" href="#webflux-client-builder-reactor-timeout"></a>Timeouts</h5>
<div class="paragraph">
<p>To configure a connection timeout:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">io.netty.channel.ChannelOption</span>;

HttpClient httpClient = HttpClient.create()
        .tcpConfiguration(client -&gt;
                client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="integer">10000</span>));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To configure a read and/or write timeout values:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">io.netty.handler.timeout.ReadTimeoutHandler</span>;
<span class="keyword">import</span> <span class="include">io.netty.handler.timeout.WriteTimeoutHandler</span>;

HttpClient httpClient = HttpClient.create()
        .tcpConfiguration(client -&gt;
                client.doOnConnected(conn -&gt; conn
                        .addHandlerLast(<span class="keyword">new</span> ReadTimeoutHandler(<span class="integer">10</span>))
                        .addHandlerLast(<span class="keyword">new</span> WriteTimeoutHandler(<span class="integer">10</span>))));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-jetty"><a class="anchor" href="#webflux-client-builder-jetty"></a>2.1.2. Jetty</h4>
<div class="paragraph">
<p>The following example shows how to customize Jetty <code>HttpClient</code> settings:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    HttpClient httpClient = <span class="keyword">new</span> HttpClient();
    httpClient.setCookieStore(...);
    ClientHttpConnector connector = <span class="keyword">new</span> JettyClientHttpConnector(httpClient);

    WebClient webClient = WebClient.builder().clientConnector(connector).build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, <code>HttpClient</code> creates its own resources (<code>Executor</code>, <code>ByteBufferPool</code>, <code>Scheduler</code>),
which remain active until the process exits or <code>stop()</code> is called.</p>
</div>
<div class="paragraph">
<p>You can share resources between multiple instances of the Jetty client (and server) and
ensure that the resources are shut down when the Spring <code>ApplicationContext</code> is closed by
declaring a Spring-managed bean of type <code>JettyResourceFactory</code>, as the following example
shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Bean</span>
    <span class="directive">public</span> JettyResourceFactory resourceFactory() {
        <span class="keyword">return</span> <span class="keyword">new</span> JettyResourceFactory();
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> WebClient webClient() {

        Consumer&lt;HttpClient&gt; customizer = client -&gt; {
            <span class="comment">// Further customizations...</span>
        };

        ClientHttpConnector connector =
                <span class="keyword">new</span> JettyClientHttpConnector(resourceFactory(), customizer); <i class="conum" data-value="1"></i><b>(1)</b>

        <span class="keyword">return</span> WebClient.builder().clientConnector(connector).build(); <i class="conum" data-value="2"></i><b>(2)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use the <code>JettyClientHttpConnector</code> constructor with resource factory.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Plug the connector into the <code>WebClient.Builder</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-retrieve"><a class="anchor" href="#webflux-client-retrieve"></a>2.2. <code>retrieve()</code></h3>
<div class="paragraph">
<p>The <code>retrieve()</code> method is the easiest way to get a response body and decode it.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    WebClient client = WebClient.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.org</span><span class="delimiter">&quot;</span></span>);

    Mono&lt;Person&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id).accept(MediaType.APPLICATION_JSON)
            .retrieve()
            .bodyToMono(Person.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also get a stream of objects decoded from the response, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Flux&lt;Quote&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/quotes</span><span class="delimiter">&quot;</span></span>).accept(MediaType.TEXT_EVENT_STREAM)
            .retrieve()
            .bodyToFlux(Quote.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, responses with 4xx or 5xx status codes result in an
<code>WebClientResponseException</code> or one of its HTTP status specific sub-classes, such as
<code>WebClientResponseException.BadRequest</code>, <code>WebClientResponseException.NotFound</code>, and others.
You can also use the <code>onStatus</code> method to customize the resulting exception,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Mono&lt;Person&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id).accept(MediaType.APPLICATION_JSON)
            .retrieve()
            .onStatus(HttpStatus::is4xxServerError, response -&gt; ...)
            .onStatus(HttpStatus::is5xxServerError, response -&gt; ...)
            .bodyToMono(Person.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When <code>onStatus</code> is used, if the response is expected to have content, then the <code>onStatus</code>
callback should consume it. If not, the content will be automatically drained to ensure
resources are released.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-exchange"><a class="anchor" href="#webflux-client-exchange"></a>2.3. <code>exchange()</code></h3>
<div class="paragraph">
<p>The <code>exchange()</code> method provides more control than the <code>retrieve</code> method. The following example is equivalent
to <code>retrieve()</code> but also provides access to the <code>ClientResponse</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Mono&lt;Person&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id).accept(MediaType.APPLICATION_JSON)
            .exchange()
            .flatMap(response -&gt; response.bodyToMono(Person.class));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>At this level, you can also create a full <code>ResponseEntity</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Mono&lt;ResponseEntity&lt;Person&gt;&gt; result = client.get()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id).accept(MediaType.APPLICATION_JSON)
            .exchange()
            .flatMap(response -&gt; response.toEntity(Person.class));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that (unlike <code>retrieve()</code>), with <code>exchange()</code>, there are no automatic error signals for
4xx and 5xx responses. You have to check the status code and decide how to proceed.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
When you use <code>exchange()</code>, you must always use any of the <code>body</code> or <code>toEntity</code> methods of
<code>ClientResponse</code> to ensure resources are released and to avoid potential issues with HTTP
connection pooling. You can use <code>bodyToMono(Void.class)</code> if no response content is
expected. However, if the response does have content, the connection
is closed and is not placed back in the pool.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-body"><a class="anchor" href="#webflux-client-body"></a>2.4. Request Body</h3>
<div class="paragraph">
<p>The request body can be encoded from an <code>Object</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Mono&lt;Person&gt; personMono = ... ;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id)
            .contentType(MediaType.APPLICATION_JSON)
            .body(personMono, Person.class)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also have a stream of objects be encoded, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Flux&lt;Person&gt; personFlux = ... ;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id)
            .contentType(MediaType.APPLICATION_STREAM_JSON)
            .body(personFlux, Person.class)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if you have the actual value, you can use the <code>syncBody</code> shortcut method,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    Person person = ... ;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/persons/{id}</span><span class="delimiter">&quot;</span></span>, id)
            .contentType(MediaType.APPLICATION_JSON)
            .syncBody(person)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-form"><a class="anchor" href="#webflux-client-body-form"></a>2.4.1. Form Data</h4>
<div class="paragraph">
<p>To send form data, you can provide a <code>MultiValueMap&lt;String, String&gt;</code> as the body. Note that the
content is automatically set to <code>application/x-www-form-urlencoded</code> by the
<code>FormHttpMessageWriter</code>. The following example shows how to use <code>MultiValueMap&lt;String, String&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; formData = ... ;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, id)
            .syncBody(formData)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also supply form data in-line by using <code>BodyInserters</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.BodyInserters</span>.*;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, id)
            .body(fromFormData(<span class="string"><span class="delimiter">&quot;</span><span class="content">k1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">v1</span><span class="delimiter">&quot;</span></span>).with(<span class="string"><span class="delimiter">&quot;</span><span class="content">k2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">v2</span><span class="delimiter">&quot;</span></span>))
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-multipart"><a class="anchor" href="#webflux-client-body-multipart"></a>2.4.2. Multipart Data</h4>
<div class="paragraph">
<p>To send multipart data, you need to provide a <code>MultiValueMap&lt;String, ?&gt;</code> whose values are
either <code>Object</code> instances that represent part content or <code>HttpEntity</code> instances that represent the content and
headers for a part. <code>MultipartBodyBuilder</code> provides a convenient API to prepare a
multipart request. The following example shows how to create a <code>MultiValueMap&lt;String, ?&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    MultipartBodyBuilder builder = <span class="keyword">new</span> MultipartBodyBuilder();
    builder.part(<span class="string"><span class="delimiter">&quot;</span><span class="content">fieldPart</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">fieldValue</span><span class="delimiter">&quot;</span></span>);
    builder.part(<span class="string"><span class="delimiter">&quot;</span><span class="content">filePart</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> FileSystemResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">...logo.png</span><span class="delimiter">&quot;</span></span>));
    builder.part(<span class="string"><span class="delimiter">&quot;</span><span class="content">jsonPart</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Jason</span><span class="delimiter">&quot;</span></span>));

    MultiValueMap&lt;<span class="predefined-type">String</span>, HttpEntity&lt;?&gt;&gt; parts = builder.build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In most cases, you do not have to specify the <code>Content-Type</code> for each part. The content
type is determined automatically based on the <code>HttpMessageWriter</code> chosen to serialize it
or, in the case of a <code>Resource</code>, based on the file extension. If necessary, you can
explicitly provide the <code>MediaType</code> to use for each part through one of the overloaded
builder <code>part</code> methods.</p>
</div>
<div class="paragraph">
<p>Once a <code>MultiValueMap</code> is prepared, the easiest way to pass it to the the <code>WebClient</code> is
through the <code>syncBody</code> method, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    MultipartBodyBuilder builder = ...;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, id)
            .syncBody(<strong>builder.build()</strong>)
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the <code>MultiValueMap</code> contains at least one non-<code>String</code> value, which could also
represent regular form data (that is, <code>application/x-www-form-urlencoded</code>), you need not
set the <code>Content-Type</code> to <code>multipart/form-data</code>. This is always the case when using
<code>MultipartBodyBuilder</code>, which ensures an <code>HttpEntity</code> wrapper.</p>
</div>
<div class="paragraph">
<p>As an alternative to <code>MultipartBodyBuilder</code>, you can also provide multipart content,
inline-style, through the built-in <code>BodyInserters</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.springframework.web.reactive.function.BodyInserters</span>.*;

    Mono&lt;<span class="predefined-type">Void</span>&gt; result = client.post()
            .uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, id)
            .body(fromMultipartData(<span class="string"><span class="delimiter">&quot;</span><span class="content">fieldPart</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>).with(<span class="string"><span class="delimiter">&quot;</span><span class="content">filePart</span><span class="delimiter">&quot;</span></span>, resource))
            .retrieve()
            .bodyToMono(<span class="predefined-type">Void</span>.class);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-filter"><a class="anchor" href="#webflux-client-filter"></a>2.5. Client Filters</h3>
<div class="paragraph">
<p>You can register a client filter (<code>ExchangeFilterFunction</code>) through the <code>WebClient.Builder</code>
in order to intercept and modify requests, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebClient client = WebClient.builder()
        .filter((request, next) -&gt; {

            ClientRequest filtered = ClientRequest.from(request)
                    .header(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>)
                    .build();

            <span class="keyword">return</span> next.exchange(filtered);
        })
        .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This can be used for cross-cutting concerns, such as authentication. The following example uses
a filter for basic authentication through a static factory method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// static import of ExchangeFilterFunctions.basicAuthentication</span>

WebClient client = WebClient.builder()
        .filter(basicAuthentication(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>))
        .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Filters apply globally to every request. To change a filter&#8217;s behavior for a specific
request, you can add request attributes to the <code>ClientRequest</code> that can then be accessed
by all filters in the chain, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebClient client = WebClient.builder()
        .filter((request, next) -&gt; {
            Optional&lt;<span class="predefined-type">Object</span>&gt; usr = request.attribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">myAttribute</span><span class="delimiter">&quot;</span></span>);
            <span class="comment">// ...</span>
        })
        .build();

client.get().uri(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.org/</span><span class="delimiter">&quot;</span></span>)
        .attribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">myAttribute</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span>)
        .retrieve()
        .bodyToMono(<span class="predefined-type">Void</span>.class);

    }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also replicate an existing <code>WebClient</code>, insert new filters, or remove already
registered filters. The following example, inserts a basic authentication filter at
index 0:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// static import of ExchangeFilterFunctions.basicAuthentication</span>

WebClient client = webClient.mutate()
        .filters(filterList -&gt; {
            filterList.add(<span class="integer">0</span>, basicAuthentication(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>));
        })
        .build();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-testing"><a class="anchor" href="#webflux-client-testing"></a>2.6. Testing</h3>
<div class="paragraph">
<p>To test code that uses the <code>WebClient</code>, you can use a mock web server, such as the
<a href="https://github.com/square/okhttp#mockwebserver">OkHttp MockWebServer</a>. To see an example
of its use, check out
<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java"><code>WebClientIntegrationTests</code></a>
in the Spring Framework test suite or the
<a href="https://github.com/square/okhttp/tree/master/samples/static-server"><code>static-server</code></a>
sample in the OkHttp repository.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-websocket"><a class="anchor" href="#webflux-websocket"></a>3. WebSockets</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>This part of the reference documentation covers support for reactive-stack WebSocket
messaging.</p>
</div>
<div class="sect2">
<h3 id="websocket-intro"><a class="anchor" href="#websocket-intro"></a>3.1. Introduction to WebSocket</h3>
<div class="paragraph">
<p>The WebSocket protocol, <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>, provides a standardized
way to establish a full-duplex, two-way communication channel between client and server
over a single TCP connection. It is a different TCP protocol from HTTP but is designed to
work over HTTP, using ports 80 and 443 and allowing re-use of existing firewall rules.</p>
</div>
<div class="paragraph">
<p>A WebSocket interaction begins with an HTTP request that uses the HTTP <code>Upgrade</code> header
to upgrade or, in this case, to switch to the WebSocket protocol. The following example
shows such an interaction:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="yaml"><span class="error">GET /spring-websocket-portfolio/portfolio HTTP/1.1</span>
<span class="key">Host</span>: <span class="string"><span class="content">localhost:8080</span></span>
<span class="key">Upgrade</span>: <span class="string"><span class="content">websocket </span></span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="key">Connection</span>: <span class="string"><span class="content">Upgrade </span></span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="key">Sec-WebSocket-Key</span>: <span class="string"><span class="content">Uc9l9TMkWGbHFD2qnFHltg==</span></span>
<span class="key">Sec-WebSocket-Protocol</span>: <span class="string"><span class="content">v10.stomp, v11.stomp</span></span>
<span class="key">Sec-WebSocket-Version</span>: <span class="string"><span class="content">13</span></span>
<span class="key">Origin</span>: <span class="string"><span class="content">http://localhost:8080</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Upgrade</code> header.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using the <code>Upgrade</code> connection.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Instead of the usual 200 status code, a server with WebSocket support returns output
similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="yaml"><span class="error">HTTP/1.1 101 Switching Protocols </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="key">Upgrade</span>: <span class="string"><span class="content">websocket</span></span>
<span class="key">Connection</span>: <span class="string"><span class="content">Upgrade</span></span>
<span class="key">Sec-WebSocket-Accept</span>: <span class="string"><span class="content">1qVdfYHU9hPOl4JYYNXF623Gzn0=</span></span>
<span class="key">Sec-WebSocket-Protocol</span>: <span class="string"><span class="content">v10.stomp</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Protocol switch</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>After a successful handshake, the TCP socket underlying the HTTP upgrade request remains
open for both the client and the server to continue to send and receive messages.</p>
</div>
<div class="paragraph">
<p>A complete introduction of how WebSockets work is beyond the scope of this document.
See RFC 6455, the WebSocket chapter of HTML5, or any of the many introductions and
tutorials on the Web.</p>
</div>
<div class="paragraph">
<p>Note that, if a WebSocket server is running behind a web server (e.g. nginx), you
likely need to configure it to pass WebSocket upgrade requests on to the WebSocket
server. Likewise, if the application runs in a cloud environment, check the
instructions of the cloud provider related to WebSocket support.</p>
</div>
<div class="sect3">
<h4 id="websocket-intro-architecture"><a class="anchor" href="#websocket-intro-architecture"></a>3.1.1. HTTP Versus WebSocket</h4>
<div class="paragraph">
<p>Even though WebSocket is designed to be HTTP-compatible and starts with an HTTP request,
it is important to understand that the two protocols lead to very different
architectures and application programming models.</p>
</div>
<div class="paragraph">
<p>In HTTP and REST, an application is modeled as many URLs. To interact with the application,
clients access those URLs, request-response style. Servers route requests to the
appropriate handler based on the HTTP URL, method, and headers.</p>
</div>
<div class="paragraph">
<p>By contrast, in WebSockets, there is usually only one URL for the initial connect.
Subsequently, all application messages flow on that same TCP connection. This points to
an entirely different asynchronous, event-driven, messaging architecture.</p>
</div>
<div class="paragraph">
<p>WebSocket is also a low-level transport protocol, which, unlike HTTP, does not prescribe
any semantics to the content of messages. That means that there is no way to route or process
a message unless the client and the server agree on message semantics.</p>
</div>
<div class="paragraph">
<p>WebSocket clients and servers can negotiate the use of a higher-level, messaging protocol
(for example, STOMP), through the <code>Sec-WebSocket-Protocol</code> header on the HTTP handshake request.
In the absence of that, they need to come up with their own conventions.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-intro-when-to-use"><a class="anchor" href="#websocket-intro-when-to-use"></a>3.1.2. When to Use WebSockets</h4>
<div class="paragraph">
<p>WebSockets can make a web page be dynamic and interactive. However, in many cases,
a combination of Ajax and HTTP streaming or long polling can provide a simple and
effective solution.</p>
</div>
<div class="paragraph">
<p>For example, news, mail, and social feeds need to update dynamically, but it may be
perfectly okay to do so every few minutes. Collaboration, games, and financial apps, on
the other hand, need to be much closer to real-time.</p>
</div>
<div class="paragraph">
<p>Latency alone is not a deciding factor. If the volume of messages is relatively low (for example,
monitoring network failures) HTTP streaming or polling can provide an effective solution.
It is the combination of low latency, high frequency, and high volume that make the best
case for the use of WebSocket.</p>
</div>
<div class="paragraph">
<p>Keep in mind also that over the Internet, restrictive proxies that are outside of your control
may preclude WebSocket interactions, either because they are not configured to pass on the
<code>Upgrade</code> header or because they close long-lived connections that appear idle. This
means that the use of WebSocket for internal applications within the firewall is a more
straightforward decision than it is for public facing applications.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-server"><a class="anchor" href="#webflux-websocket-server"></a>3.2. WebSocket API</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The Spring Framework provides a WebSocket API that you can use to write client- and
server-side applications that handle WebSocket messages.</p>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-handler"><a class="anchor" href="#webflux-websocket-server-handler"></a>3.2.1. Server</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-handler">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>To create a WebSocket server, you can first create a <code>WebSocketHandler</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.web.reactive.socket.WebSocketHandler</span>;
<span class="keyword">import</span> <span class="include">org.springframework.web.reactive.socket.WebSocketSession</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">MyWebSocketHandler</span> <span class="directive">implements</span> WebSocketHandler {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; handle(WebSocketSession session) {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then you can map it to a URL and add a <code>WebSocketHandlerAdapter</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">WebConfig</span> {

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> HandlerMapping handlerMapping() {
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, WebSocketHandler&gt; map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();
        map.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> MyWebSocketHandler());

        SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();
        mapping.setUrlMap(map);
        mapping.setOrder(-<span class="integer">1</span>); <span class="comment">// before annotated controllers</span>
        <span class="keyword">return</span> mapping;
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> WebSocketHandlerAdapter handlerAdapter() {
        <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websockethandler"><a class="anchor" href="#webflux-websockethandler"></a>3.2.2. <code>WebSocketHandler</code></h4>
<div class="paragraph">
<p>The <code>handle</code> method of <code>WebSocketHandler</code> takes <code>WebSocketSession</code> and returns <code>Mono&lt;Void&gt;</code>
to indicate when application handling of the session is complete. The session is handled
through two streams, one for inbound and one for outbound messages. The following table
describes the two methods that handle the streams:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>WebSocketSession</code> method</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;WebSocketMessage&gt; receive()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides access to the inbound message stream and completes when the connection is closed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono&lt;Void&gt; send(Publisher&lt;WebSocketMessage&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Takes a source for outgoing messages, writes the messages, and returns a <code>Mono&lt;Void&gt;</code> that
  completes when the source completes and writing is done.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A <code>WebSocketHandler</code> must compose the inbound and outbound streams into a unified flow and
return a <code>Mono&lt;Void&gt;</code> that reflects the completion of that flow. Depending on application
requirements, the unified flow completes when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Either the inbound or the outbound message stream completes.</p>
</li>
<li>
<p>The inbound stream completes (that is, the connection closed), while the outbound stream is infinite.</p>
</li>
<li>
<p>At a chosen point, through the <code>close</code> method of <code>WebSocketSession</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When inbound and outbound message streams are composed together, there is no need to
check if the connection is open, since Reactive Streams signals terminate activity.
The inbound stream receives a completion or error signal, and the outbound stream
receives a cancellation signal.</p>
</div>
<div class="paragraph">
<p>The most basic implementation of a handler is one that handles the inbound stream. The
following example shows such an implementation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ExampleHandler</span> <span class="directive">implements</span> WebSocketHandler {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; handle(WebSocketSession session) {
        <span class="keyword">return</span> session.receive()            <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext(message -&gt; {
                    <span class="comment">// ...                  </span><i class="conum" data-value="2"></i><b>(2)</b>
                })
                .concatMap(message -&gt; {
                    <span class="comment">// ...                  </span><i class="conum" data-value="3"></i><b>(3)</b>
                })
                .then();                    <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Access the stream of inbound messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Do something with each message.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Perform nested asynchronous operations that use the message content.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Return a <code>Mono&lt;Void&gt;</code> that completes when receiving completes.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For nested, asynchronous operations, you may need to call <code>message.retain()</code> on underlying
servers that use pooled data buffers (for example, Netty). Otherwise, the data buffer may be
released before you have had a chance to read the data. For more background, see
<a href="core.html#databuffers">Data Buffers and Codecs</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following implementation combines the inbound and outbound streams:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ExampleHandler</span> <span class="directive">implements</span> WebSocketHandler {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; handle(WebSocketSession session) {

        Flux&lt;WebSocketMessage&gt; output = session.receive()               <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext(message -&gt; {
                    <span class="comment">// ...</span>
                })
                .concatMap(message -&gt; {
                    <span class="comment">// ...</span>
                })
                .map(value -&gt; session.textMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">Echo </span><span class="delimiter">&quot;</span></span> + value));    <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="keyword">return</span> session.send(output);                                    <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Handle the inbound message stream.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create the outbound message, producing a combined flow.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return a <code>Mono&lt;Void&gt;</code> that does not complete while we continue to receive.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Inbound and outbound streams can be independent and be joined only for completion,
as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ExampleHandler</span> <span class="directive">implements</span> WebSocketHandler {

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Mono&lt;<span class="predefined-type">Void</span>&gt; handle(WebSocketSession session) {

        Mono&lt;<span class="predefined-type">Void</span>&gt; input = session.receive()                                <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext(message -&gt; {
                    <span class="comment">// ...</span>
                })
                .concatMap(message -&gt; {
                    <span class="comment">// ...</span>
                })
                .then();

        Flux&lt;<span class="predefined-type">String</span>&gt; source = ... ;
        Mono&lt;<span class="predefined-type">Void</span>&gt; output = session.send(source.map(session::textMessage)); <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="keyword">return</span> Mono.zip(input, output).then();                              <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Handle inbound message stream.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Send outgoing messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Join the streams and return a <code>Mono&lt;Void&gt;</code> that completes when either stream ends.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-databuffer"><a class="anchor" href="#webflux-websocket-databuffer"></a>3.2.3. <code>DataBuffer</code></h4>
<div class="paragraph">
<p><code>DataBuffer</code> is the representation for a byte buffer in WebFlux. The Spring Core part of
the reference has more on that in the section on
<a href="core.html#databuffers">Data Buffers and Codecs</a>. The key point to understand is that on some
servers like Netty, byte buffers are pooled and reference counted, and must be released
when consumed to avoid memory leaks.</p>
</div>
<div class="paragraph">
<p>When running on Netty, applications must use <code>DataBufferUtils.retain(dataBuffer)</code> if they
wish to hold on input data buffers in order to ensure they are not released, and
subsequently use <code>DataBufferUtils.release(dataBuffer)</code> when the buffers are consumed.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-handshake"><a class="anchor" href="#webflux-websocket-server-handshake"></a>3.2.4. Handshake</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-handshake">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p><code>WebSocketHandlerAdapter</code> delegates to a <code>WebSocketService</code>. By default, that is an instance
of <code>HandshakeWebSocketService</code>, which performs basic checks on the WebSocket request and
then uses <code>RequestUpgradeStrategy</code> for the server in use. Currently, there is built-in
support for Reactor Netty, Tomcat, Jetty, and Undertow.</p>
</div>
<div class="paragraph">
<p><code>HandshakeWebSocketService</code> exposes a <code>sessionAttributePredicate</code> property that allows
setting a <code>Predicate&lt;String&gt;</code> to extract attributes from the <code>WebSession</code> and insert them
into the attributes of the <code>WebSocketSession</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-config"><a class="anchor" href="#webflux-websocket-server-config"></a>3.2.5. Server Configation</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-runtime-configuration">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The <code>RequestUpgradeStrategy</code> for each server exposes WebSocket-related configuration
options available for the underlying WebSocket engine. The following example sets
WebSocket options when running on Tomcat:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">WebConfig</span> {

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> WebSocketHandlerAdapter handlerAdapter() {
        <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter(webSocketService());
    }

    <span class="annotation">@Bean</span>
    <span class="directive">public</span> WebSocketService webSocketService() {
        TomcatRequestUpgradeStrategy strategy = <span class="keyword">new</span> TomcatRequestUpgradeStrategy();
        strategy.setMaxSessionIdleTimeout(<span class="integer">0L</span>);
        <span class="keyword">return</span> <span class="keyword">new</span> HandshakeWebSocketService(strategy);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Check the upgrade strategy for your server to see what options are available. Currently,
only Tomcat and Jetty expose such options.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-cors"><a class="anchor" href="#webflux-websocket-server-cors"></a>3.2.6. CORS</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-allowed-origins">Same as in the Servlet stack</a></span></p>
</div>
<div class="paragraph">
<p>The easiest way to configure CORS and restrict access to a WebSocket endpoint is to
have your <code>WebSocketHandler</code> implement <code>CorsConfigurationSource</code> and return a
<code>CorsConfiguraiton</code> with allowed origins, headers, and other details. If you cannot do
that, you can also set the <code>corsConfigurations</code> property on the <code>SimpleUrlHandler</code> to
specify CORS settings by URL pattern. If both are specified, they are combined by using the
<code>combine</code> method on <code>CorsConfiguration</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-client"><a class="anchor" href="#webflux-websocket-client"></a>3.2.7. Client</h4>
<div class="paragraph">
<p>Spring WebFlux provides a <code>WebSocketClient</code> abstraction with implementations for
Reactor Netty, Tomcat, Jetty, Undertow, and standard Java (that is, JSR-356).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Tomcat client is effectively an extension of the standard Java one with some extra
functionality in the <code>WebSocketSession</code> handling to take advantage of the Tomcat-specific
API to suspend receiving messages for back pressure.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To start a WebSocket session, you can create an instance of the client and use its <code>execute</code>
methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">WebSocketClient client = <span class="keyword">new</span> ReactorNettyWebSocketClient();

<span class="predefined-type">URI</span> url = <span class="keyword">new</span> <span class="predefined-type">URI</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">ws://localhost:8080/path</span><span class="delimiter">&quot;</span></span>);
client.execute(url, session -&gt;
        session.receive()
                .doOnNext(<span class="predefined-type">System</span>.out::println)
                .then());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Some clients, such as Jetty, implement <code>Lifecycle</code> and need to be stopped and started
before you can use them. All clients have constructor options related to configuration
of the underlying WebSocket client.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-test"><a class="anchor" href="#webflux-test"></a>4. Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web.html#testing">Same in Spring MVC</a></span></p>
</div>
<div class="paragraph">
<p>The <code>spring-test</code> module provides mock implementations of <code>ServerHttpRequest</code>,
<code>ServerHttpResponse</code>, and <code>ServerWebExchange</code>.
See <a href="testing.html#mock-objects-web-reactive">Spring Web Reactive</a> for a discussion of mock objects.</p>
</div>
<div class="paragraph">
<p><a href="testing.html#webtestclient"><code>WebTestClient</code></a> builds on these mock request and
response objects to provide support for testing WebFlux applications without an HTTP
server. You can use the <code>WebTestClient</code> for end-to-end integration tests, too.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-reactive-libraries"><a class="anchor" href="#webflux-reactive-libraries"></a>5. Reactive Libraries</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>spring-webflux</code> depends on <code>reactor-core</code> and uses it internally to compose asynchronous
logic and to provide Reactive Streams support. Generally, WebFlux APIs return <code>Flux</code> or
<code>Mono</code> (since those are used internally) and leniently accept any Reactive Streams
<code>Publisher</code> implementation as input. The use of <code>Flux</code> versus <code>Mono</code> is important, because it
helps to express cardinality&#8201;&#8212;&#8201;for example, whether a single or multiple asynchronous values are
expected, and that can be essential for making decisions (for example, when encoding or
decoding HTTP messages).</p>
</div>
<div class="paragraph">
<p>For annotated controllers, WebFlux transparently adapts to the reactive library chosen by
the application. This is done with the help of the
<a href="https://docs.spring.io/spring-framework/docs/5.1.4.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html"><code>ReactiveAdapterRegistry</code></a>, which
provides pluggable support for reactive library and other asynchronous types. The registry
has built-in support for RxJava and <code>CompletableFuture</code>, but you can register others, too.</p>
</div>
<div class="paragraph">
<p>For functional APIs (such as <a href="#webflux-fn">Functional Endpoints</a>, the <code>WebClient</code>, and others), the general rules
for WebFlux APIs apply&#8201;&#8212;&#8201;<code>Flux</code> and <code>Mono</code> as return values and a Reactive Streams
<code>Publisher</code> as input. When a <code>Publisher</code>, whether custom or from another reactive library,
is provided, it can be treated only as a stream with unknown semantics (0..N). If, however,
the semantics are known, you can wrap it with <code>Flux</code> or <code>Mono.from(Publisher)</code> instead
of passing the raw <code>Publisher</code>.</p>
</div>
<div class="paragraph">
<p>For example, given a <code>Publisher</code> that is not a <code>Mono</code>, the Jackson JSON message writer
expects multiple values. If the media type implies an infinite stream (for example,
<code>application/json+stream</code>), values are written and flushed individually. Otherwise,
values are buffered into a list and rendered as a JSON array.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.1.4.RELEASE<br>
Last updated 2019-01-09 12:23:41 UTC
</div>
</div>
<script src="tocbot-3.0.2/tocbot.js"></script>
<script>

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();


    var link = document.createElement("a");
    link.setAttribute("href", "index.html");
    link.innerHTML = "<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";
    var p = document.createElement("p");
    p.appendChild(link);
    var toc = document.getElementById('toc')
    var next = document.getElementById('toctitle').nextElementSibling;
    toc.insertBefore(p, next);

</script>
</body>
</html>